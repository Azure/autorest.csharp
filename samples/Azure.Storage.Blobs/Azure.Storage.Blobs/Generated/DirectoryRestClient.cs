// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Storage.Blobs.Models;

namespace Azure.Storage.Blobs
{
    internal partial class DirectoryRestClient
    {
        private string url;
        private string version;
        private PathRenameMode? pathRenameMode;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of DirectoryRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="url"> The URL of the service account, container, or blob that is the targe of the desired operation. </param>
        /// <param name="version"> Specifies the version of the operation to use for this request. </param>
        /// <param name="pathRenameMode"> Determines the behavior of the rename operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="url"/> or <paramref name="version"/> is null. </exception>
        public DirectoryRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, PathRenameMode? pathRenameMode = null)
        {
            if (url == null)
            {
                throw new ArgumentNullException(nameof(url));
            }
            if (version == null)
            {
                throw new ArgumentNullException(nameof(version));
            }

            this.url = url;
            this.version = version;
            this.pathRenameMode = pathRenameMode;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateCreateRequest(string filesystem, string path, int? timeout, string directoryProperties, string posixPermissions, string posixUmask, string requestId, DirectoryHttpHeaders directoryHttpHeaders, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            uri.AppendQuery("resource", "directory", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (directoryProperties != null)
            {
                request.Headers.Add("x-ms-properties", directoryProperties);
            }
            if (posixPermissions != null)
            {
                request.Headers.Add("x-ms-permissions", posixPermissions);
            }
            if (posixUmask != null)
            {
                request.Headers.Add("x-ms-umask", posixUmask);
            }
            if (directoryHttpHeaders?.CacheControl != null)
            {
                request.Headers.Add("x-ms-cache-control", directoryHttpHeaders.CacheControl);
            }
            if (directoryHttpHeaders?.ContentType != null)
            {
                request.Headers.Add("x-ms-content-type", directoryHttpHeaders.ContentType);
            }
            if (directoryHttpHeaders?.ContentEncoding != null)
            {
                request.Headers.Add("x-ms-content-encoding", directoryHttpHeaders.ContentEncoding);
            }
            if (directoryHttpHeaders?.ContentLanguage != null)
            {
                request.Headers.Add("x-ms-content-language", directoryHttpHeaders.ContentLanguage);
            }
            if (directoryHttpHeaders?.ContentDisposition != null)
            {
                request.Headers.Add("x-ms-content-disposition", directoryHttpHeaders.ContentDisposition);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Create a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<DirectoryCreateHeaders>> CreateAsync(string filesystem, string path, int? timeout = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateCreateRequest(filesystem, path, timeout, directoryProperties, posixPermissions, posixUmask, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new DirectoryCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Create a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<DirectoryCreateHeaders> Create(string filesystem, string path, int? timeout = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateCreateRequest(filesystem, path, timeout, directoryProperties, posixPermissions, posixUmask, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new DirectoryCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRenameRequest(string filesystem, string path, string renameSource, int? timeout, string marker, string directoryProperties, string posixPermissions, string posixUmask, string sourceLeaseId, string requestId, DirectoryHttpHeaders directoryHttpHeaders, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions, SourceModifiedAccessConditions sourceModifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (marker != null)
            {
                uri.AppendQuery("continuation", marker, true);
            }
            if (pathRenameMode != null)
            {
                uri.AppendQuery("mode", pathRenameMode.Value.ToSerialString(), true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-rename-source", renameSource);
            if (directoryProperties != null)
            {
                request.Headers.Add("x-ms-properties", directoryProperties);
            }
            if (posixPermissions != null)
            {
                request.Headers.Add("x-ms-permissions", posixPermissions);
            }
            if (posixUmask != null)
            {
                request.Headers.Add("x-ms-umask", posixUmask);
            }
            if (directoryHttpHeaders?.CacheControl != null)
            {
                request.Headers.Add("x-ms-cache-control", directoryHttpHeaders.CacheControl);
            }
            if (directoryHttpHeaders?.ContentType != null)
            {
                request.Headers.Add("x-ms-content-type", directoryHttpHeaders.ContentType);
            }
            if (directoryHttpHeaders?.ContentEncoding != null)
            {
                request.Headers.Add("x-ms-content-encoding", directoryHttpHeaders.ContentEncoding);
            }
            if (directoryHttpHeaders?.ContentLanguage != null)
            {
                request.Headers.Add("x-ms-content-language", directoryHttpHeaders.ContentLanguage);
            }
            if (directoryHttpHeaders?.ContentDisposition != null)
            {
                request.Headers.Add("x-ms-content-disposition", directoryHttpHeaders.ContentDisposition);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (sourceLeaseId != null)
            {
                request.Headers.Add("x-ms-source-lease-id", sourceLeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Rename a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations). To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="renameSource"> The file or directory to be renamed. The value must have the following format: &quot;/{filesysystem}/{path}&quot;.  If &quot;x-ms-properties&quot; is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="marker"> When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="sourceLeaseId"> A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/>, <paramref name="path"/>, or <paramref name="renameSource"/> is null. </exception>
        public async Task<ResponseWithHeaders<DirectoryRenameHeaders>> RenameAsync(string filesystem, string path, string renameSource, int? timeout = null, string marker = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string sourceLeaseId = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }
            if (renameSource == null)
            {
                throw new ArgumentNullException(nameof(renameSource));
            }

            using var message = CreateRenameRequest(filesystem, path, renameSource, timeout, marker, directoryProperties, posixPermissions, posixUmask, sourceLeaseId, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new DirectoryRenameHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Rename a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations). To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="renameSource"> The file or directory to be renamed. The value must have the following format: &quot;/{filesysystem}/{path}&quot;.  If &quot;x-ms-properties&quot; is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="marker"> When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="sourceLeaseId"> A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/>, <paramref name="path"/>, or <paramref name="renameSource"/> is null. </exception>
        public ResponseWithHeaders<DirectoryRenameHeaders> Rename(string filesystem, string path, string renameSource, int? timeout = null, string marker = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string sourceLeaseId = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }
            if (renameSource == null)
            {
                throw new ArgumentNullException(nameof(renameSource));
            }

            using var message = CreateRenameRequest(filesystem, path, renameSource, timeout, marker, directoryProperties, posixPermissions, posixUmask, sourceLeaseId, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new DirectoryRenameHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string filesystem, string path, bool recursiveDirectoryDelete, int? timeout, string marker, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("recursive", recursiveDirectoryDelete, true);
            if (marker != null)
            {
                uri.AppendQuery("continuation", marker, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Deletes the directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="recursiveDirectoryDelete"> If &quot;true&quot;, all paths beneath the directory will be deleted. If &quot;false&quot; and the directory is non-empty, an error occurs. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="marker"> When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<DirectoryDeleteHeaders>> DeleteAsync(string filesystem, string path, bool recursiveDirectoryDelete, int? timeout = null, string marker = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateDeleteRequest(filesystem, path, recursiveDirectoryDelete, timeout, marker, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new DirectoryDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Deletes the directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="recursiveDirectoryDelete"> If &quot;true&quot;, all paths beneath the directory will be deleted. If &quot;false&quot; and the directory is non-empty, an error occurs. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="marker"> When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<DirectoryDeleteHeaders> Delete(string filesystem, string path, bool recursiveDirectoryDelete, int? timeout = null, string marker = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateDeleteRequest(filesystem, path, recursiveDirectoryDelete, timeout, marker, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new DirectoryDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetAccessControlRequest(string filesystem, string path, int? timeout, string owner, string group, string posixPermissions, string posixAcl, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            uri.AppendQuery("action", "setAccessControl", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (owner != null)
            {
                request.Headers.Add("x-ms-owner", owner);
            }
            if (group != null)
            {
                request.Headers.Add("x-ms-group", group);
            }
            if (posixPermissions != null)
            {
                request.Headers.Add("x-ms-permissions", posixPermissions);
            }
            if (posixAcl != null)
            {
                request.Headers.Add("x-ms-acl", posixAcl);
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Set the owner, group, permissions, or access control list for a directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="owner"> Optional. The owner of the blob or directory. </param>
        /// <param name="group"> Optional. The owning group of the blob or directory. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixAcl"> Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format &quot;[scope:][type]:[id]:[permissions]&quot;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<DirectorySetAccessControlHeaders>> SetAccessControlAsync(string filesystem, string path, int? timeout = null, string owner = null, string group = null, string posixPermissions = null, string posixAcl = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateSetAccessControlRequest(filesystem, path, timeout, owner, group, posixPermissions, posixAcl, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new DirectorySetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Set the owner, group, permissions, or access control list for a directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="owner"> Optional. The owner of the blob or directory. </param>
        /// <param name="group"> Optional. The owning group of the blob or directory. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixAcl"> Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format &quot;[scope:][type]:[id]:[permissions]&quot;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<DirectorySetAccessControlHeaders> SetAccessControl(string filesystem, string path, int? timeout = null, string owner = null, string group = null, string posixPermissions = null, string posixAcl = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateSetAccessControlRequest(filesystem, path, timeout, owner, group, posixPermissions, posixAcl, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new DirectorySetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetAccessControlRequest(string filesystem, string path, int? timeout, bool? upn, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            uri.AppendQuery("action", "getAccessControl", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (upn != null)
            {
                uri.AppendQuery("upn", upn.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Get the owner, group, permissions, or access control list for a directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="upn"> Optional. Valid only when Hierarchical Namespace is enabled for the account. If &quot;true&quot;, the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If &quot;false&quot;, the values will be returned as Azure Active Directory Object IDs. The default value is false. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<DirectoryGetAccessControlHeaders>> GetAccessControlAsync(string filesystem, string path, int? timeout = null, bool? upn = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateGetAccessControlRequest(filesystem, path, timeout, upn, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new DirectoryGetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get the owner, group, permissions, or access control list for a directory. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="upn"> Optional. Valid only when Hierarchical Namespace is enabled for the account. If &quot;true&quot;, the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If &quot;false&quot;, the values will be returned as Azure Active Directory Object IDs. The default value is false. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<DirectoryGetAccessControlHeaders> GetAccessControl(string filesystem, string path, int? timeout = null, bool? upn = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateGetAccessControlRequest(filesystem, path, timeout, upn, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new DirectoryGetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
