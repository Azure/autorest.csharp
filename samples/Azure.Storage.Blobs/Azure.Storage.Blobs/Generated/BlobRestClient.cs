// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Storage.Blobs.Models;

namespace Azure.Storage.Blobs
{
    internal partial class BlobRestClient
    {
        private string url;
        private string version;
        private PathRenameMode? pathRenameMode;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of BlobRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="url"> The URL of the service account, container, or blob that is the targe of the desired operation. </param>
        /// <param name="version"> Specifies the version of the operation to use for this request. </param>
        /// <param name="pathRenameMode"> Determines the behavior of the rename operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="url"/> or <paramref name="version"/> is null. </exception>
        public BlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version, PathRenameMode? pathRenameMode = null)
        {
            if (url == null)
            {
                throw new ArgumentNullException(nameof(url));
            }
            if (version == null)
            {
                throw new ArgumentNullException(nameof(version));
            }

            this.url = url;
            this.version = version;
            this.pathRenameMode = pathRenameMode;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateDownloadRequest(string containerName, string blob, string snapshot, string versionId, int? timeout, string range, bool? rangeGetContentHash, bool? rangeGetContentCRC64, string requestId, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (range != null)
            {
                request.Headers.Add("x-ms-range", range);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (rangeGetContentHash != null)
            {
                request.Headers.Add("x-ms-range-get-content-md5", rangeGetContentHash.Value);
            }
            if (rangeGetContentCRC64 != null)
            {
                request.Headers.Add("x-ms-range-get-content-crc64", rangeGetContentCRC64.Value);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="rangeGetContentHash"> When set to true and specified together with the Range, the service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in size. </param>
        /// <param name="rangeGetContentCRC64"> When set to true and specified together with the Range, the service returns the CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<Stream, BlobDownloadHeaders>> DownloadAsync(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, string range = null, bool? rangeGetContentHash = null, bool? rangeGetContentCRC64 = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateDownloadRequest(containerName, blob, snapshot, versionId, timeout, range, rangeGetContentHash, rangeGetContentCRC64, requestId, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobDownloadHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 206:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 304:
                    return ResponseWithHeaders.FromValue<Stream, BlobDownloadHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="rangeGetContentHash"> When set to true and specified together with the Range, the service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in size. </param>
        /// <param name="rangeGetContentCRC64"> When set to true and specified together with the Range, the service returns the CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<Stream, BlobDownloadHeaders> Download(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, string range = null, bool? rangeGetContentHash = null, bool? rangeGetContentCRC64 = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateDownloadRequest(containerName, blob, snapshot, versionId, timeout, range, rangeGetContentHash, rangeGetContentCRC64, requestId, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobDownloadHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 206:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 304:
                    return ResponseWithHeaders.FromValue<Stream, BlobDownloadHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPropertiesRequest(string containerName, string blob, string snapshot, string versionId, int? timeout, string requestId, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            return message;
        }

        /// <summary> The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobGetPropertiesHeaders>> GetPropertiesAsync(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPropertiesRequest(containerName, blob, snapshot, versionId, timeout, requestId, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobGetPropertiesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 304:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobGetPropertiesHeaders> GetProperties(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPropertiesRequest(containerName, blob, snapshot, versionId, timeout, requestId, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobGetPropertiesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 304:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string containerName, string blob, string snapshot, string versionId, int? timeout, DeleteSnapshotsOption? deleteSnapshots, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (deleteSnapshots != null)
            {
                request.Headers.Add("x-ms-delete-snapshots", deleteSnapshots.Value.ToSerialString());
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> If the storage account&apos;s soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account&apos;s soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob&apos;s data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob&apos;s storage until it is permanently removed. Use the List Blobs API and specify the &quot;include=deleted&quot; query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound). </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="deleteSnapshots"> Required if the blob has associated snapshots. Specify one of the following two options: include: Delete the base blob and all of its snapshots. only: Delete only the blob&apos;s snapshots and not the blob itself. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobDeleteHeaders>> DeleteAsync(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, DeleteSnapshotsOption? deleteSnapshots = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateDeleteRequest(containerName, blob, snapshot, versionId, timeout, deleteSnapshots, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> If the storage account&apos;s soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account&apos;s soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob&apos;s data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob&apos;s storage until it is permanently removed. Use the List Blobs API and specify the &quot;include=deleted&quot; query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound). </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="deleteSnapshots"> Required if the blob has associated snapshots. Specify one of the following two options: include: Delete the base blob and all of its snapshots. only: Delete only the blob&apos;s snapshots and not the blob itself. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobDeleteHeaders> Delete(string containerName, string blob, string snapshot = null, string versionId = null, int? timeout = null, DeleteSnapshotsOption? deleteSnapshots = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateDeleteRequest(containerName, blob, snapshot, versionId, timeout, deleteSnapshots, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetAccessControlRequest(string filesystem, string path, int? timeout, string owner, string group, string posixPermissions, string posixAcl, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            uri.AppendQuery("action", "setAccessControl", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (owner != null)
            {
                request.Headers.Add("x-ms-owner", owner);
            }
            if (group != null)
            {
                request.Headers.Add("x-ms-group", group);
            }
            if (posixPermissions != null)
            {
                request.Headers.Add("x-ms-permissions", posixPermissions);
            }
            if (posixAcl != null)
            {
                request.Headers.Add("x-ms-acl", posixAcl);
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Set the owner, group, permissions, or access control list for a blob. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="owner"> Optional. The owner of the blob or directory. </param>
        /// <param name="group"> Optional. The owning group of the blob or directory. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixAcl"> Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format &quot;[scope:][type]:[id]:[permissions]&quot;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetAccessControlHeaders>> SetAccessControlAsync(string filesystem, string path, int? timeout = null, string owner = null, string group = null, string posixPermissions = null, string posixAcl = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateSetAccessControlRequest(filesystem, path, timeout, owner, group, posixPermissions, posixAcl, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Set the owner, group, permissions, or access control list for a blob. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="owner"> Optional. The owner of the blob or directory. </param>
        /// <param name="group"> Optional. The owning group of the blob or directory. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixAcl"> Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format &quot;[scope:][type]:[id]:[permissions]&quot;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<BlobSetAccessControlHeaders> SetAccessControl(string filesystem, string path, int? timeout = null, string owner = null, string group = null, string posixPermissions = null, string posixAcl = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateSetAccessControlRequest(filesystem, path, timeout, owner, group, posixPermissions, posixAcl, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetAccessControlRequest(string filesystem, string path, int? timeout, bool? upn, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            uri.AppendQuery("action", "getAccessControl", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (upn != null)
            {
                uri.AppendQuery("upn", upn.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Get the owner, group, permissions, or access control list for a blob. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="upn"> Optional. Valid only when Hierarchical Namespace is enabled for the account. If &quot;true&quot;, the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If &quot;false&quot;, the values will be returned as Azure Active Directory Object IDs. The default value is false. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobGetAccessControlHeaders>> GetAccessControlAsync(string filesystem, string path, int? timeout = null, bool? upn = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateGetAccessControlRequest(filesystem, path, timeout, upn, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobGetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get the owner, group, permissions, or access control list for a blob. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="upn"> Optional. Valid only when Hierarchical Namespace is enabled for the account. If &quot;true&quot;, the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If &quot;false&quot;, the values will be returned as Azure Active Directory Object IDs. The default value is false. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/> or <paramref name="path"/> is null. </exception>
        public ResponseWithHeaders<BlobGetAccessControlHeaders> GetAccessControl(string filesystem, string path, int? timeout = null, bool? upn = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }

            using var message = CreateGetAccessControlRequest(filesystem, path, timeout, upn, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobGetAccessControlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRenameRequest(string filesystem, string path, string renameSource, int? timeout, string directoryProperties, string posixPermissions, string posixUmask, string sourceLeaseId, string requestId, DirectoryHttpHeaders directoryHttpHeaders, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions, SourceModifiedAccessConditions sourceModifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(filesystem, true);
            uri.AppendPath("/", false);
            uri.AppendPath(path, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (pathRenameMode != null)
            {
                uri.AppendQuery("mode", pathRenameMode.Value.ToSerialString(), true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-rename-source", renameSource);
            if (directoryProperties != null)
            {
                request.Headers.Add("x-ms-properties", directoryProperties);
            }
            if (posixPermissions != null)
            {
                request.Headers.Add("x-ms-permissions", posixPermissions);
            }
            if (posixUmask != null)
            {
                request.Headers.Add("x-ms-umask", posixUmask);
            }
            if (directoryHttpHeaders?.CacheControl != null)
            {
                request.Headers.Add("x-ms-cache-control", directoryHttpHeaders.CacheControl);
            }
            if (directoryHttpHeaders?.ContentType != null)
            {
                request.Headers.Add("x-ms-content-type", directoryHttpHeaders.ContentType);
            }
            if (directoryHttpHeaders?.ContentEncoding != null)
            {
                request.Headers.Add("x-ms-content-encoding", directoryHttpHeaders.ContentEncoding);
            }
            if (directoryHttpHeaders?.ContentLanguage != null)
            {
                request.Headers.Add("x-ms-content-language", directoryHttpHeaders.ContentLanguage);
            }
            if (directoryHttpHeaders?.ContentDisposition != null)
            {
                request.Headers.Add("x-ms-content-disposition", directoryHttpHeaders.ContentDisposition);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (sourceLeaseId != null)
            {
                request.Headers.Add("x-ms-source-lease-id", sourceLeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="renameSource"> The file or directory to be renamed. The value must have the following format: &quot;/{filesysystem}/{path}&quot;.  If &quot;x-ms-properties&quot; is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="sourceLeaseId"> A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/>, <paramref name="path"/>, or <paramref name="renameSource"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobRenameHeaders>> RenameAsync(string filesystem, string path, string renameSource, int? timeout = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string sourceLeaseId = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }
            if (renameSource == null)
            {
                throw new ArgumentNullException(nameof(renameSource));
            }

            using var message = CreateRenameRequest(filesystem, path, renameSource, timeout, directoryProperties, posixPermissions, posixUmask, sourceLeaseId, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobRenameHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: &quot;*&quot;. </summary>
        /// <param name="filesystem"> The filesystem name. </param>
        /// <param name="path"> The namespace path to a file or directory. </param>
        /// <param name="renameSource"> The file or directory to be renamed. The value must have the following format: &quot;/{filesysystem}/{path}&quot;.  If &quot;x-ms-properties&quot; is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="directoryProperties"> Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs &quot;n1=v1, n2=v2, ...&quot;, where each value is base64 encoded. </param>
        /// <param name="posixPermissions"> Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. </param>
        /// <param name="posixUmask"> Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. </param>
        /// <param name="sourceLeaseId"> A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="directoryHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filesystem"/>, <paramref name="path"/>, or <paramref name="renameSource"/> is null. </exception>
        public ResponseWithHeaders<BlobRenameHeaders> Rename(string filesystem, string path, string renameSource, int? timeout = null, string directoryProperties = null, string posixPermissions = null, string posixUmask = null, string sourceLeaseId = null, string requestId = null, DirectoryHttpHeaders directoryHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (filesystem == null)
            {
                throw new ArgumentNullException(nameof(filesystem));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }
            if (renameSource == null)
            {
                throw new ArgumentNullException(nameof(renameSource));
            }

            using var message = CreateRenameRequest(filesystem, path, renameSource, timeout, directoryProperties, posixPermissions, posixUmask, sourceLeaseId, requestId, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobRenameHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUndeleteRequest(string containerName, string blob, int? timeout, string requestId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "undelete", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Undelete a blob that was previously soft deleted. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobUndeleteHeaders>> UndeleteAsync(string containerName, string blob, int? timeout = null, string requestId = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateUndeleteRequest(containerName, blob, timeout, requestId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobUndeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Undelete a blob that was previously soft deleted. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobUndeleteHeaders> Undelete(string containerName, string blob, int? timeout = null, string requestId = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateUndeleteRequest(containerName, blob, timeout, requestId);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobUndeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetExpiryRequest(string containerName, string blob, BlobExpiryOptions expiryOptions, int? timeout, string requestId, string expiresOn)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "expiry", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("x-ms-expiry-option", expiryOptions.ToString());
            if (expiresOn != null)
            {
                request.Headers.Add("x-ms-expiry-time", expiresOn);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Sets the time a blob will expire and be deleted. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="expiryOptions"> Required. Indicates mode of the expiry time. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="expiresOn"> The time to set the blob to expiry. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetExpiryHeaders>> SetExpiryAsync(string containerName, string blob, BlobExpiryOptions expiryOptions, int? timeout = null, string requestId = null, string expiresOn = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetExpiryRequest(containerName, blob, expiryOptions, timeout, requestId, expiresOn);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetExpiryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Sets the time a blob will expire and be deleted. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="expiryOptions"> Required. Indicates mode of the expiry time. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="expiresOn"> The time to set the blob to expiry. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobSetExpiryHeaders> SetExpiry(string containerName, string blob, BlobExpiryOptions expiryOptions, int? timeout = null, string requestId = null, string expiresOn = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetExpiryRequest(containerName, blob, expiryOptions, timeout, requestId, expiresOn);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetExpiryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetHttpHeadersRequest(string containerName, string blob, int? timeout, string requestId, BlobHttpHeaders blobHttpHeaders, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "properties", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (blobHttpHeaders?.BlobCacheControl != null)
            {
                request.Headers.Add("x-ms-blob-cache-control", blobHttpHeaders.BlobCacheControl);
            }
            if (blobHttpHeaders?.BlobContentType != null)
            {
                request.Headers.Add("x-ms-blob-content-type", blobHttpHeaders.BlobContentType);
            }
            if (blobHttpHeaders?.BlobContentHash != null)
            {
                request.Headers.Add("x-ms-blob-content-md5", blobHttpHeaders.BlobContentHash);
            }
            if (blobHttpHeaders?.BlobContentEncoding != null)
            {
                request.Headers.Add("x-ms-blob-content-encoding", blobHttpHeaders.BlobContentEncoding);
            }
            if (blobHttpHeaders?.BlobContentLanguage != null)
            {
                request.Headers.Add("x-ms-blob-content-language", blobHttpHeaders.BlobContentLanguage);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            if (blobHttpHeaders?.BlobContentDisposition != null)
            {
                request.Headers.Add("x-ms-blob-content-disposition", blobHttpHeaders.BlobContentDisposition);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Set HTTP Headers operation sets system properties on the blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetHttpHeadersHeaders>> SetHttpHeadersAsync(string containerName, string blob, int? timeout = null, string requestId = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetHttpHeadersRequest(containerName, blob, timeout, requestId, blobHttpHeaders, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetHttpHeadersHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Set HTTP Headers operation sets system properties on the blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobSetHttpHeadersHeaders> SetHttpHeaders(string containerName, string blob, int? timeout = null, string requestId = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetHttpHeadersRequest(containerName, blob, timeout, requestId, blobHttpHeaders, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetHttpHeadersHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetMetadataRequest(string containerName, string blob, int? timeout, string metadata, string requestId, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "metadata", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta", metadata);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetMetadataHeaders>> SetMetadataAsync(string containerName, string blob, int? timeout = null, string metadata = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetMetadataRequest(containerName, blob, timeout, metadata, requestId, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetMetadataHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobSetMetadataHeaders> SetMetadata(string containerName, string blob, int? timeout = null, string metadata = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetMetadataRequest(containerName, blob, timeout, metadata, requestId, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetMetadataHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAcquireLeaseRequest(string containerName, string blob, int? timeout, long? duration, string proposedLeaseId, string requestId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "lease", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-lease-action", "acquire");
            if (duration != null)
            {
                request.Headers.Add("x-ms-lease-duration", duration.Value);
            }
            if (proposedLeaseId != null)
            {
                request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="duration"> Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change. </param>
        /// <param name="proposedLeaseId"> Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobAcquireLeaseHeaders>> AcquireLeaseAsync(string containerName, string blob, int? timeout = null, long? duration = null, string proposedLeaseId = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateAcquireLeaseRequest(containerName, blob, timeout, duration, proposedLeaseId, requestId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobAcquireLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="duration"> Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change. </param>
        /// <param name="proposedLeaseId"> Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobAcquireLeaseHeaders> AcquireLease(string containerName, string blob, int? timeout = null, long? duration = null, string proposedLeaseId = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateAcquireLeaseRequest(containerName, blob, timeout, duration, proposedLeaseId, requestId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobAcquireLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateReleaseLeaseRequest(string containerName, string blob, string leaseId, int? timeout, string requestId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "lease", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-lease-action", "release");
            request.Headers.Add("x-ms-lease-id", leaseId);
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="leaseId"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobReleaseLeaseHeaders>> ReleaseLeaseAsync(string containerName, string blob, string leaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }

            using var message = CreateReleaseLeaseRequest(containerName, blob, leaseId, timeout, requestId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobReleaseLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="leaseId"/> is null. </exception>
        public ResponseWithHeaders<BlobReleaseLeaseHeaders> ReleaseLease(string containerName, string blob, string leaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }

            using var message = CreateReleaseLeaseRequest(containerName, blob, leaseId, timeout, requestId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobReleaseLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRenewLeaseRequest(string containerName, string blob, string leaseId, int? timeout, string requestId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "lease", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-lease-action", "renew");
            request.Headers.Add("x-ms-lease-id", leaseId);
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="leaseId"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobRenewLeaseHeaders>> RenewLeaseAsync(string containerName, string blob, string leaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }

            using var message = CreateRenewLeaseRequest(containerName, blob, leaseId, timeout, requestId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobRenewLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="leaseId"/> is null. </exception>
        public ResponseWithHeaders<BlobRenewLeaseHeaders> RenewLease(string containerName, string blob, string leaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }

            using var message = CreateRenewLeaseRequest(containerName, blob, leaseId, timeout, requestId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobRenewLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateChangeLeaseRequest(string containerName, string blob, string leaseId, string proposedLeaseId, int? timeout, string requestId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "lease", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-lease-action", "change");
            request.Headers.Add("x-ms-lease-id", leaseId);
            request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="proposedLeaseId"> Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, <paramref name="leaseId"/>, or <paramref name="proposedLeaseId"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobChangeLeaseHeaders>> ChangeLeaseAsync(string containerName, string blob, string leaseId, string proposedLeaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }
            if (proposedLeaseId == null)
            {
                throw new ArgumentNullException(nameof(proposedLeaseId));
            }

            using var message = CreateChangeLeaseRequest(containerName, blob, leaseId, proposedLeaseId, timeout, requestId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobChangeLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="leaseId"> Specifies the current lease ID on the resource. </param>
        /// <param name="proposedLeaseId"> Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, <paramref name="leaseId"/>, or <paramref name="proposedLeaseId"/> is null. </exception>
        public ResponseWithHeaders<BlobChangeLeaseHeaders> ChangeLease(string containerName, string blob, string leaseId, string proposedLeaseId, int? timeout = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (leaseId == null)
            {
                throw new ArgumentNullException(nameof(leaseId));
            }
            if (proposedLeaseId == null)
            {
                throw new ArgumentNullException(nameof(proposedLeaseId));
            }

            using var message = CreateChangeLeaseRequest(containerName, blob, leaseId, proposedLeaseId, timeout, requestId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobChangeLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateBreakLeaseRequest(string containerName, string blob, int? timeout, long? breakPeriod, string requestId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "lease", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-lease-action", "break");
            if (breakPeriod != null)
            {
                request.Headers.Add("x-ms-lease-break-period", breakPeriod.Value);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="breakPeriod"> For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobBreakLeaseHeaders>> BreakLeaseAsync(string containerName, string blob, int? timeout = null, long? breakPeriod = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateBreakLeaseRequest(containerName, blob, timeout, breakPeriod, requestId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobBreakLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="breakPeriod"> For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobBreakLeaseHeaders> BreakLease(string containerName, string blob, int? timeout = null, long? breakPeriod = null, string requestId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateBreakLeaseRequest(containerName, blob, timeout, breakPeriod, requestId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobBreakLeaseHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateSnapshotRequest(string containerName, string blob, int? timeout, string metadata, string requestId, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions, LeaseAccessConditions leaseAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "snapshot", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta", metadata);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Create Snapshot operation creates a read-only snapshot of a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobCreateSnapshotHeaders>> CreateSnapshotAsync(string containerName, string blob, int? timeout = null, string metadata = null, string requestId = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateSnapshotRequest(containerName, blob, timeout, metadata, requestId, cpkInfo, cpkScopeInfo, modifiedAccessConditions, leaseAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobCreateSnapshotHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Create Snapshot operation creates a read-only snapshot of a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobCreateSnapshotHeaders> CreateSnapshot(string containerName, string blob, int? timeout = null, string metadata = null, string requestId = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateSnapshotRequest(containerName, blob, timeout, metadata, requestId, cpkInfo, cpkScopeInfo, modifiedAccessConditions, leaseAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobCreateSnapshotHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateStartCopyFromUriRequest(string containerName, string blob, Uri copySource, int? timeout, string metadata, AccessTier? tier, RehydratePriority? rehydratePriority, string requestId, string blobTagsString, bool? sealBlob, SourceModifiedAccessConditions sourceModifiedAccessConditions, ModifiedAccessConditions modifiedAccessConditions, LeaseAccessConditions leaseAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta", metadata);
            }
            if (tier != null)
            {
                request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
            }
            if (rehydratePriority != null)
            {
                request.Headers.Add("x-ms-rehydrate-priority", rehydratePriority.Value.ToSerialString());
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfTags != null)
            {
                request.Headers.Add("x-ms-source-if-tags", sourceModifiedAccessConditions.SourceIfTags);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-copy-source", copySource);
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            if (blobTagsString != null)
            {
                request.Headers.Add("x-ms-tags", blobTagsString);
            }
            if (sealBlob != null)
            {
                request.Headers.Add("x-ms-seal-blob", sealBlob.Value);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Start Copy From URL operation copies a blob or an internet resource to a new blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the blob. </param>
        /// <param name="rehydratePriority"> Optional: Indicates the priority with which to rehydrate an archived blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="blobTagsString"> Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags. </param>
        /// <param name="sealBlob"> Overrides the sealed state of the destination blob.  Service version 2019-12-12 and newer. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copySource"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobStartCopyFromUriHeaders>> StartCopyFromUriAsync(string containerName, string blob, Uri copySource, int? timeout = null, string metadata = null, AccessTier? tier = null, RehydratePriority? rehydratePriority = null, string requestId = null, string blobTagsString = null, bool? sealBlob = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateStartCopyFromUriRequest(containerName, blob, copySource, timeout, metadata, tier, rehydratePriority, requestId, blobTagsString, sealBlob, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobStartCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Start Copy From URL operation copies a blob or an internet resource to a new blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the blob. </param>
        /// <param name="rehydratePriority"> Optional: Indicates the priority with which to rehydrate an archived blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="blobTagsString"> Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags. </param>
        /// <param name="sealBlob"> Overrides the sealed state of the destination blob.  Service version 2019-12-12 and newer. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copySource"/> is null. </exception>
        public ResponseWithHeaders<BlobStartCopyFromUriHeaders> StartCopyFromUri(string containerName, string blob, Uri copySource, int? timeout = null, string metadata = null, AccessTier? tier = null, RehydratePriority? rehydratePriority = null, string requestId = null, string blobTagsString = null, bool? sealBlob = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateStartCopyFromUriRequest(containerName, blob, copySource, timeout, metadata, tier, rehydratePriority, requestId, blobTagsString, sealBlob, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobStartCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCopyFromUriRequest(string containerName, string blob, Uri copySource, int? timeout, string metadata, AccessTier? tier, string requestId, byte[] sourceContentHash, string blobTagsString, SourceModifiedAccessConditions sourceModifiedAccessConditions, ModifiedAccessConditions modifiedAccessConditions, LeaseAccessConditions leaseAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-requires-sync", "true");
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta", metadata);
            }
            if (tier != null)
            {
                request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-copy-source", copySource);
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            if (sourceContentHash != null)
            {
                request.Headers.Add("x-ms-source-content-md5", sourceContentHash);
            }
            if (blobTagsString != null)
            {
                request.Headers.Add("x-ms-tags", blobTagsString);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="sourceContentHash"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="blobTagsString"> Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copySource"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobCopyFromUriHeaders>> CopyFromUriAsync(string containerName, string blob, Uri copySource, int? timeout = null, string metadata = null, AccessTier? tier = null, string requestId = null, byte[] sourceContentHash = null, string blobTagsString = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateCopyFromUriRequest(containerName, blob, copySource, timeout, metadata, tier, requestId, sourceContentHash, blobTagsString, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                case 304:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="sourceContentHash"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="blobTagsString"> Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copySource"/> is null. </exception>
        public ResponseWithHeaders<BlobCopyFromUriHeaders> CopyFromUri(string containerName, string blob, Uri copySource, int? timeout = null, string metadata = null, AccessTier? tier = null, string requestId = null, byte[] sourceContentHash = null, string blobTagsString = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateCopyFromUriRequest(containerName, blob, copySource, timeout, metadata, tier, requestId, sourceContentHash, blobTagsString, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                case 304:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAbortCopyFromUriRequest(string containerName, string blob, string copyId, int? timeout, string requestId, LeaseAccessConditions leaseAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "copy", true);
            uri.AppendQuery("copyid", copyId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-copy-action", "abort");
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copyId"> The copy identifier provided in the x-ms-copy-id header of the original Copy Blob operation. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copyId"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobAbortCopyFromUriHeaders>> AbortCopyFromUriAsync(string containerName, string blob, string copyId, int? timeout = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copyId == null)
            {
                throw new ArgumentNullException(nameof(copyId));
            }

            using var message = CreateAbortCopyFromUriRequest(containerName, blob, copyId, timeout, requestId, leaseAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobAbortCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copyId"> The copy identifier provided in the x-ms-copy-id header of the original Copy Blob operation. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="copyId"/> is null. </exception>
        public ResponseWithHeaders<BlobAbortCopyFromUriHeaders> AbortCopyFromUri(string containerName, string blob, string copyId, int? timeout = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copyId == null)
            {
                throw new ArgumentNullException(nameof(copyId));
            }

            using var message = CreateAbortCopyFromUriRequest(containerName, blob, copyId, timeout, requestId, leaseAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobAbortCopyFromUriHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetAccessTierRequest(string containerName, string blob, AccessTier tier, string snapshot, string versionId, int? timeout, RehydratePriority? rehydratePriority, string requestId, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "tier", true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-access-tier", tier.ToString());
            if (rehydratePriority != null)
            {
                request.Headers.Add("x-ms-rehydrate-priority", rehydratePriority.Value.ToSerialString());
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob&apos;s tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob&apos;s tier determines Hot/Cool/Archive storage type. This operation does not update the blob&apos;s ETag. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="tier"> Indicates the tier to be set on the blob. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="rehydratePriority"> Optional: Indicates the priority with which to rehydrate an archived blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetAccessTierHeaders>> SetAccessTierAsync(string containerName, string blob, AccessTier tier, string snapshot = null, string versionId = null, int? timeout = null, RehydratePriority? rehydratePriority = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetAccessTierRequest(containerName, blob, tier, snapshot, versionId, timeout, rehydratePriority, requestId, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetAccessTierHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob&apos;s tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob&apos;s tier determines Hot/Cool/Archive storage type. This operation does not update the blob&apos;s ETag. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="tier"> Indicates the tier to be set on the blob. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="rehydratePriority"> Optional: Indicates the priority with which to rehydrate an archived blob. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobSetAccessTierHeaders> SetAccessTier(string containerName, string blob, AccessTier tier, string snapshot = null, string versionId = null, int? timeout = null, RehydratePriority? rehydratePriority = null, string requestId = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetAccessTierRequest(containerName, blob, tier, snapshot, versionId, timeout, rehydratePriority, requestId, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetAccessTierHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateQueryRequest(string containerName, string blob, string snapshot, int? timeout, string requestId, QueryRequest queryRequest, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "query", true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            request.Headers.Add("Content-Type", "application/xml");
            request.Headers.Add("Accept", "application/xml");
            if (queryRequest != null)
            {
                var content = new XmlWriterContent();
                content.XmlWriter.WriteObjectValue(queryRequest, "QueryRequest");
                request.Content = content;
            }
            return message;
        }

        /// <summary> The Query operation enables users to select/project on blob data by providing simple query expressions. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="queryRequest"> the query request. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<Stream, BlobQueryHeaders>> QueryAsync(string containerName, string blob, string snapshot = null, int? timeout = null, string requestId = null, QueryRequest queryRequest = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateQueryRequest(containerName, blob, snapshot, timeout, requestId, queryRequest, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobQueryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 206:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Query operation enables users to select/project on blob data by providing simple query expressions. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="queryRequest"> the query request. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<Stream, BlobQueryHeaders> Query(string containerName, string blob, string snapshot = null, int? timeout = null, string requestId = null, QueryRequest queryRequest = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateQueryRequest(containerName, blob, snapshot, timeout, requestId, queryRequest, leaseAccessConditions, cpkInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobQueryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 206:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTagsRequest(string containerName, string blob, int? timeout, string requestId, string snapshot, string versionId, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "tags", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-version", version);
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Get Tags operation enables users to get the tags associated with a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobTags, BlobGetTagsHeaders>> GetTagsAsync(string containerName, string blob, int? timeout = null, string requestId = null, string snapshot = null, string versionId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetTagsRequest(containerName, blob, timeout, requestId, snapshot, versionId, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobGetTagsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BlobTags value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("Tags") is XElement tagsElement)
                        {
                            value = BlobTags.DeserializeBlobTags(tagsElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Get Tags operation enables users to get the tags associated with a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobTags, BlobGetTagsHeaders> GetTags(string containerName, string blob, int? timeout = null, string requestId = null, string snapshot = null, string versionId = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetTagsRequest(containerName, blob, timeout, requestId, snapshot, versionId, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobGetTagsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BlobTags value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("Tags") is XElement tagsElement)
                        {
                            value = BlobTags.DeserializeBlobTags(tagsElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetTagsRequest(string containerName, string blob, int? timeout, string versionId, byte[] transactionalContentHash, byte[] transactionalContentCrc64, string requestId, BlobTags tags, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "tags", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (versionId != null)
            {
                uri.AppendQuery("versionid", versionId, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-version", version);
            if (transactionalContentHash != null)
            {
                request.Headers.Add("Content-MD5", transactionalContentHash);
            }
            if (transactionalContentCrc64 != null)
            {
                request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64);
            }
            if (requestId != null)
            {
                request.Headers.Add("x-ms-client-request-id", requestId);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("Content-Type", "application/xml");
            request.Headers.Add("Accept", "application/xml");
            if (tags != null)
            {
                var content = new XmlWriterContent();
                content.XmlWriter.WriteObjectValue(tags, "Tags");
                request.Content = content;
            }
            return message;
        }

        /// <summary> The Set Tags operation enables users to set tags on a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="transactionalContentHash"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="tags"> Blob tags. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<BlobSetTagsHeaders>> SetTagsAsync(string containerName, string blob, int? timeout = null, string versionId = null, byte[] transactionalContentHash = null, byte[] transactionalContentCrc64 = null, string requestId = null, BlobTags tags = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetTagsRequest(containerName, blob, timeout, versionId, transactionalContentHash, transactionalContentCrc64, requestId, tags, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new BlobSetTagsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Set Tags operation enables users to set tags on a blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="versionId"> The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It&apos;s for service version 2019-10-10 and newer. </param>
        /// <param name="transactionalContentHash"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="requestId"> Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled. </param>
        /// <param name="tags"> Blob tags. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<BlobSetTagsHeaders> SetTags(string containerName, string blob, int? timeout = null, string versionId = null, byte[] transactionalContentHash = null, byte[] transactionalContentCrc64 = null, string requestId = null, BlobTags tags = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSetTagsRequest(containerName, blob, timeout, versionId, transactionalContentHash, transactionalContentCrc64, requestId, tags, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new BlobSetTagsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
