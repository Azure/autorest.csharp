// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.DocumentTranslation
{
    /// <summary> The DocumentTranslation service client. </summary>
    public partial class DocumentTranslationClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DocumentTranslationClient for mocking. </summary>
        protected DocumentTranslationClient()
        {
        }

        /// <summary> Initializes a new instance of DocumentTranslationClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public DocumentTranslationClient(string endpoint, AzureKeyCredential credential) : this(endpoint, credential, new DocumentTranslationClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DocumentTranslationClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public DocumentTranslationClient(string endpoint, AzureKeyCredential credential, DocumentTranslationClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DocumentTranslationClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary> Returns the status for a specific document. </summary>
        /// <param name="id"> Format - uuid.  The batch id. </param>
        /// <param name="documentId"> Format - uuid.  The document id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDocumentStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetDocumentStatusAsync(Guid.NewGuid(), Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("path").ToString());
        /// Console.WriteLine(result.GetProperty("sourcePath").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("to").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("progress").ToString());
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("characterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the translation status for a specific document based on the request Id and document Id.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DocumentStatus</c>:
        /// <code>{
        ///   path: string, # Optional. Location of the document or folder
        ///   sourcePath: string, # Required. Location of the source document
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   to: string, # Required. To language
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   progress: number, # Required. Progress of the translation if available
        ///   id: DocumentStatusId, # Required. Document Id
        ///   characterCharged: number, # Optional. Character charged by the API
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDocumentStatusAsync(Guid id, Guid documentId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetDocumentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDocumentStatusRequest(id, documentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the status for a specific document. </summary>
        /// <param name="id"> Format - uuid.  The batch id. </param>
        /// <param name="documentId"> Format - uuid.  The document id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDocumentStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetDocumentStatus(Guid.NewGuid(), Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("path").ToString());
        /// Console.WriteLine(result.GetProperty("sourcePath").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("to").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("progress").ToString());
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("characterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the translation status for a specific document based on the request Id and document Id.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DocumentStatus</c>:
        /// <code>{
        ///   path: string, # Optional. Location of the document or folder
        ///   sourcePath: string, # Required. Location of the source document
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   to: string, # Required. To language
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   progress: number, # Required. Progress of the translation if available
        ///   id: DocumentStatusId, # Required. Document Id
        ///   characterCharged: number, # Optional. Character charged by the API
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDocumentStatus(Guid id, Guid documentId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetDocumentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDocumentStatusRequest(id, documentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the status for a document translation request. </summary>
        /// <param name="id"> Format - uuid.  The operation id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTranslationStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetTranslationStatusAsync(Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the status for a document translation request.
        /// The status includes the overall request status, as well as the status for documents that are being translated as part of that request.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationStatus</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTranslationStatusAsync(Guid id, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetTranslationStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTranslationStatusRequest(id, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the status for a document translation request. </summary>
        /// <param name="id"> Format - uuid.  The operation id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTranslationStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetTranslationStatus(Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the status for a document translation request.
        /// The status includes the overall request status, as well as the status for documents that are being translated as part of that request.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationStatus</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTranslationStatus(Guid id, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetTranslationStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTranslationStatusRequest(id, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancel a currently processing or queued translation. </summary>
        /// <param name="id"> Format - uuid.  The operation-id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTranslationAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.CancelTranslationAsync(Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Cancel a currently processing or queued translation.
        /// Cancel a currently processing or queued translation.
        /// A translation will not be cancelled if it is already completed or failed or cancelling. A bad request will be returned.
        /// All documents that have completed translation will not be cancelled and will be charged.
        /// All pending documents will be cancelled if possible.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationStatus</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CancelTranslationAsync(Guid id, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.CancelTranslation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTranslationRequest(id, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancel a currently processing or queued translation. </summary>
        /// <param name="id"> Format - uuid.  The operation-id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTranslation with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.CancelTranslation(Guid.NewGuid());
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        /// Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Cancel a currently processing or queued translation.
        /// Cancel a currently processing or queued translation.
        /// A translation will not be cancelled if it is already completed or failed or cancelling. A bad request will be returned.
        /// All documents that have completed translation will not be cancelled and will be charged.
        /// All pending documents will be cancelled if possible.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationStatus</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CancelTranslation(Guid id, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.CancelTranslation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTranslationRequest(id, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of supported document formats. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedDocumentFormatsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetSupportedDocumentFormatsAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("format").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("contentTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("defaultVersion").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("versions")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// The list of supported document formats supported by the Document Translation service.
        /// The list includes the common file extension, as well as the content-type if using the upload API.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedFileFormats</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       format: string, # Required. Name of the format
        ///       fileExtensions: [string], # Required. Supported file extension for this format
        ///       contentTypes: [string], # Required. Supported Content-Types for this format
        ///       defaultVersion: string, # Optional. Default version if none is specified
        ///       versions: [string], # Optional. Supported Version
        ///     }
        ///   ], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSupportedDocumentFormatsAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedDocumentFormats");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedDocumentFormatsRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of supported document formats. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedDocumentFormats and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetSupportedDocumentFormats();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("format").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("contentTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("defaultVersion").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("versions")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// The list of supported document formats supported by the Document Translation service.
        /// The list includes the common file extension, as well as the content-type if using the upload API.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedFileFormats</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       format: string, # Required. Name of the format
        ///       fileExtensions: [string], # Required. Supported file extension for this format
        ///       contentTypes: [string], # Required. Supported Content-Types for this format
        ///       defaultVersion: string, # Optional. Default version if none is specified
        ///       versions: [string], # Optional. Supported Version
        ///     }
        ///   ], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSupportedDocumentFormats(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedDocumentFormats");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedDocumentFormatsRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the list of supported glossary formats. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedGlossaryFormatsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetSupportedGlossaryFormatsAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("format").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("contentTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("defaultVersion").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("versions")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// The list of supported glossary formats supported by the Document Translation service.
        /// The list includes the common file extension used.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedFileFormats</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       format: string, # Required. Name of the format
        ///       fileExtensions: [string], # Required. Supported file extension for this format
        ///       contentTypes: [string], # Required. Supported Content-Types for this format
        ///       defaultVersion: string, # Optional. Default version if none is specified
        ///       versions: [string], # Optional. Supported Version
        ///     }
        ///   ], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSupportedGlossaryFormatsAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedGlossaryFormats");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedGlossaryFormatsRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the list of supported glossary formats. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedGlossaryFormats and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetSupportedGlossaryFormats();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("format").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("contentTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("defaultVersion").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("versions")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// The list of supported glossary formats supported by the Document Translation service.
        /// The list includes the common file extension used.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedFileFormats</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       format: string, # Required. Name of the format
        ///       fileExtensions: [string], # Required. Supported file extension for this format
        ///       contentTypes: [string], # Required. Supported Content-Types for this format
        ///       defaultVersion: string, # Optional. Default version if none is specified
        ///       versions: [string], # Optional. Supported Version
        ///     }
        ///   ], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSupportedGlossaryFormats(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedGlossaryFormats");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedGlossaryFormatsRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of supported storage sources. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedStorageSourcesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetSupportedStorageSourcesAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns a list of storage sources/options supported by the Document Translation service.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedStorageSources</c>:
        /// <code>{
        ///   value: [&quot;AzureBlob&quot;], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSupportedStorageSourcesAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedStorageSources");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedStorageSourcesRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of supported storage sources. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedStorageSources and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetSupportedStorageSources();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns a list of storage sources/options supported by the Document Translation service.
        /// 
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SupportedStorageSources</c>:
        /// <code>{
        ///   value: [&quot;AzureBlob&quot;], # Required. list of objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSupportedStorageSources(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.GetSupportedStorageSources");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedStorageSourcesRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of batch requests submitted and the status for each request. </summary>
        /// <param name="top">
        /// $top indicates the total number of records the user wants to be returned across all pages.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="skip">
        /// $skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="maxpagesize">
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server&apos;s default page size.
        /// </param>
        /// <param name="ids"> Ids to use in filtering. </param>
        /// <param name="statuses"> Statuses to use in filtering. </param>
        /// <param name="createdDateTimeUtcStart"> the start datetime to get items after. </param>
        /// <param name="createdDateTimeUtcEnd"> the end datetime to get items before. </param>
        /// <param name="orderBy"> the sorting query for the collection (ex: &apos;CreatedDateTimeUtc asc&apos;, &apos;CreatedDateTimeUtc desc&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTranslationsStatusAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTranslationsStatusAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTranslationsStatusAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTranslationsStatusAsync(1234, 1234, 1234, new Guid[]{Guid.NewGuid()}, new String[]{"<statuses>"}, DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, new String[]{"<orderBy>"}))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns a list of batch requests submitted and the status for each request.
        /// This list only contains batch requests submitted by the user (based on the resource).
        ///             
        /// If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a partial result and include a continuation token in the response.
        /// The absence of a continuation token means that no additional pages are available.
        ///             
        /// $top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an offset for the collection.
        ///             
        /// $top indicates the total number of records the user wants to be returned across all pages.
        /// $skip indicates the number of records to skip from the list of batches based on the sorting method specified.  By default, we sort by descending start time.
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// $orderBy query parameter can be used to sort the returned list (ex &quot;$orderBy=createdDateTimeUtc asc&quot; or &quot;$orderBy=createdDateTimeUtc desc&quot;).
        /// The default sorting is descending by createdDateTimeUtc.
        /// Some query parameters can be used to filter the returned list (ex: &quot;status=Succeeded,Cancelled&quot;) will only return succeeded and cancelled operations.
        /// createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to specify a range of datetime to filter the returned list by.
        /// The supported filtering query parameters are (status, ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
        ///             
        /// The server honors the values specified by the client. However, clients must be prepared to handle responses that contain a different page size or contain a continuation token.
        ///             
        /// When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
        /// Note: If the server can&apos;t honor $top and/or $skip, the server must return an error to the client informing about it instead of just ignoring the query options.
        /// This reduces the risk of the client making assumptions about the data returned.
        /// 
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationsStatusValue</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTranslationsStatusAsync(int? top = null, int? skip = null, int? maxpagesize = null, IEnumerable<Guid> ids = null, IEnumerable<string> statuses = null, DateTimeOffset? createdDateTimeUtcStart = null, DateTimeOffset? createdDateTimeUtcEnd = null, IEnumerable<string> orderBy = null, RequestContext context = null)
        {
            return GetTranslationsStatusImplementationAsync("DocumentTranslationClient.GetTranslationsStatus", top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetTranslationsStatusImplementationAsync(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTranslationsStatusRequest(top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context)
                        : CreateGetTranslationsStatusNextPageRequest(nextLink, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Returns a list of batch requests submitted and the status for each request. </summary>
        /// <param name="top">
        /// $top indicates the total number of records the user wants to be returned across all pages.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="skip">
        /// $skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="maxpagesize">
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server&apos;s default page size.
        /// </param>
        /// <param name="ids"> Ids to use in filtering. </param>
        /// <param name="statuses"> Statuses to use in filtering. </param>
        /// <param name="createdDateTimeUtcStart"> the start datetime to get items after. </param>
        /// <param name="createdDateTimeUtcEnd"> the end datetime to get items before. </param>
        /// <param name="orderBy"> the sorting query for the collection (ex: &apos;CreatedDateTimeUtc asc&apos;, &apos;CreatedDateTimeUtc desc&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTranslationsStatus and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTranslationsStatus())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTranslationsStatus with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTranslationsStatus(1234, 1234, 1234, new Guid[]{Guid.NewGuid()}, new String[]{"<statuses>"}, DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, new String[]{"<orderBy>"}))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("total").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("failed").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("success").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("inProgress").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("notYetStarted").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("cancelled").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").GetProperty("totalCharacterCharged").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns a list of batch requests submitted and the status for each request.
        /// This list only contains batch requests submitted by the user (based on the resource).
        ///             
        /// If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a partial result and include a continuation token in the response.
        /// The absence of a continuation token means that no additional pages are available.
        ///             
        /// $top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an offset for the collection.
        ///             
        /// $top indicates the total number of records the user wants to be returned across all pages.
        /// $skip indicates the number of records to skip from the list of batches based on the sorting method specified.  By default, we sort by descending start time.
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// $orderBy query parameter can be used to sort the returned list (ex &quot;$orderBy=createdDateTimeUtc asc&quot; or &quot;$orderBy=createdDateTimeUtc desc&quot;).
        /// The default sorting is descending by createdDateTimeUtc.
        /// Some query parameters can be used to filter the returned list (ex: &quot;status=Succeeded,Cancelled&quot;) will only return succeeded and cancelled operations.
        /// createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to specify a range of datetime to filter the returned list by.
        /// The supported filtering query parameters are (status, ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
        ///             
        /// The server honors the values specified by the client. However, clients must be prepared to handle responses that contain a different page size or contain a continuation token.
        ///             
        /// When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
        /// Note: If the server can&apos;t honor $top and/or $skip, the server must return an error to the client informing about it instead of just ignoring the query options.
        /// This reduces the risk of the client making assumptions about the data returned.
        /// 
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TranslationsStatusValue</c>:
        /// <code>{
        ///   id: TranslationStatusId, # Required. Id of the operation.
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   summary: {
        ///     total: number, # Required. Total count
        ///     failed: number, # Required. Failed count
        ///     success: number, # Required. Number of Success
        ///     inProgress: number, # Required. Number of in progress
        ///     notYetStarted: number, # Required. Count of not yet started
        ///     cancelled: number, # Required. Number of cancelled
        ///     totalCharacterCharged: number, # Required. Total characters charged by the API
        ///   }, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTranslationsStatus(int? top = null, int? skip = null, int? maxpagesize = null, IEnumerable<Guid> ids = null, IEnumerable<string> statuses = null, DateTimeOffset? createdDateTimeUtcStart = null, DateTimeOffset? createdDateTimeUtcEnd = null, IEnumerable<string> orderBy = null, RequestContext context = null)
        {
            return GetTranslationsStatusImplementation("DocumentTranslationClient.GetTranslationsStatus", top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
        }

        private Pageable<BinaryData> GetTranslationsStatusImplementation(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTranslationsStatusRequest(top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context)
                        : CreateGetTranslationsStatusNextPageRequest(nextLink, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Returns the status for all documents in a batch document translation request. </summary>
        /// <param name="id"> Format - uuid.  The operation id. </param>
        /// <param name="top">
        /// $top indicates the total number of records the user wants to be returned across all pages.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="skip">
        /// $skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="maxpagesize">
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server&apos;s default page size.
        /// </param>
        /// <param name="ids"> Ids to use in filtering. </param>
        /// <param name="statuses"> Statuses to use in filtering. </param>
        /// <param name="createdDateTimeUtcStart"> the start datetime to get items after. </param>
        /// <param name="createdDateTimeUtcEnd"> the end datetime to get items before. </param>
        /// <param name="orderBy"> the sorting query for the collection (ex: &apos;CreatedDateTimeUtc asc&apos;, &apos;CreatedDateTimeUtc desc&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDocumentsStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetDocumentsStatusAsync(Guid.NewGuid()))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("sourcePath").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("to").ToString());
        ///     Console.WriteLine(result.GetProperty("progress").ToString());
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDocumentsStatusAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetDocumentsStatusAsync(Guid.NewGuid(), 1234, 1234, 1234, new Guid[]{Guid.NewGuid()}, new String[]{"<statuses>"}, DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, new String[]{"<orderBy>"}))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("path").ToString());
        ///     Console.WriteLine(result.GetProperty("sourcePath").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("to").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("progress").ToString());
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("characterCharged").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the status for all documents in a batch document translation request.
        ///             
        /// If the number of documents in the response exceeds our paging limit, server-side paging is used.
        /// Paginated responses indicate a partial result and include a continuation token in the response. The absence of a continuation token means that no additional pages are available.
        ///             
        /// $top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an offset for the collection.
        ///             
        /// $top indicates the total number of records the user wants to be returned across all pages.
        /// $skip indicates the number of records to skip from the list of document status held by the server based on the sorting method specified.  By default, we sort by descending start time.
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// $orderBy query parameter can be used to sort the returned list (ex &quot;$orderBy=createdDateTimeUtc asc&quot; or &quot;$orderBy=createdDateTimeUtc desc&quot;).
        /// The default sorting is descending by createdDateTimeUtc.
        /// Some query parameters can be used to filter the returned list (ex: &quot;status=Succeeded,Cancelled&quot;) will only return succeeded and cancelled documents.
        /// createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to specify a range of datetime to filter the returned list by.
        /// The supported filtering query parameters are (status, ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
        ///             
        /// When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
        /// Note: If the server can&apos;t honor $top and/or $skip, the server must return an error to the client informing about it instead of just ignoring the query options.
        /// This reduces the risk of the client making assumptions about the data returned.
        /// 
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DocumentsStatusValue</c>:
        /// <code>{
        ///   path: string, # Optional. Location of the document or folder
        ///   sourcePath: string, # Required. Location of the source document
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   to: string, # Required. To language
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   progress: number, # Required. Progress of the translation if available
        ///   id: DocumentStatusId, # Required. Document Id
        ///   characterCharged: number, # Optional. Character charged by the API
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDocumentsStatusAsync(Guid id, int? top = null, int? skip = null, int? maxpagesize = null, IEnumerable<Guid> ids = null, IEnumerable<string> statuses = null, DateTimeOffset? createdDateTimeUtcStart = null, DateTimeOffset? createdDateTimeUtcEnd = null, IEnumerable<string> orderBy = null, RequestContext context = null)
        {
            return GetDocumentsStatusImplementationAsync("DocumentTranslationClient.GetDocumentsStatus", id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDocumentsStatusImplementationAsync(string diagnosticsScopeName, Guid id, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDocumentsStatusRequest(id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context)
                        : CreateGetDocumentsStatusNextPageRequest(nextLink, id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Returns the status for all documents in a batch document translation request. </summary>
        /// <param name="id"> Format - uuid.  The operation id. </param>
        /// <param name="top">
        /// $top indicates the total number of records the user wants to be returned across all pages.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="skip">
        /// $skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
        ///             
        /// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
        /// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
        ///             
        /// Note: If the server can&apos;t honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.
        /// </param>
        /// <param name="maxpagesize">
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server&apos;s default page size.
        /// </param>
        /// <param name="ids"> Ids to use in filtering. </param>
        /// <param name="statuses"> Statuses to use in filtering. </param>
        /// <param name="createdDateTimeUtcStart"> the start datetime to get items after. </param>
        /// <param name="createdDateTimeUtcEnd"> the end datetime to get items before. </param>
        /// <param name="orderBy"> the sorting query for the collection (ex: &apos;CreatedDateTimeUtc asc&apos;, &apos;CreatedDateTimeUtc desc&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDocumentsStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetDocumentsStatus(Guid.NewGuid()))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("sourcePath").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("to").ToString());
        ///     Console.WriteLine(result.GetProperty("progress").ToString());
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDocumentsStatus with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetDocumentsStatus(Guid.NewGuid(), 1234, 1234, 1234, new Guid[]{Guid.NewGuid()}, new String[]{"<statuses>"}, DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, new String[]{"<orderBy>"}))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("path").ToString());
        ///     Console.WriteLine(result.GetProperty("sourcePath").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTimeUtc").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("to").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innerError").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("progress").ToString());
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("characterCharged").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Returns the status for all documents in a batch document translation request.
        ///             
        /// If the number of documents in the response exceeds our paging limit, server-side paging is used.
        /// Paginated responses indicate a partial result and include a continuation token in the response. The absence of a continuation token means that no additional pages are available.
        ///             
        /// $top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an offset for the collection.
        ///             
        /// $top indicates the total number of records the user wants to be returned across all pages.
        /// $skip indicates the number of records to skip from the list of document status held by the server based on the sorting method specified.  By default, we sort by descending start time.
        /// $maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
        ///             
        /// $orderBy query parameter can be used to sort the returned list (ex &quot;$orderBy=createdDateTimeUtc asc&quot; or &quot;$orderBy=createdDateTimeUtc desc&quot;).
        /// The default sorting is descending by createdDateTimeUtc.
        /// Some query parameters can be used to filter the returned list (ex: &quot;status=Succeeded,Cancelled&quot;) will only return succeeded and cancelled documents.
        /// createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to specify a range of datetime to filter the returned list by.
        /// The supported filtering query parameters are (status, ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
        ///             
        /// When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
        /// Note: If the server can&apos;t honor $top and/or $skip, the server must return an error to the client informing about it instead of just ignoring the query options.
        /// This reduces the risk of the client making assumptions about the data returned.
        /// 
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DocumentsStatusValue</c>:
        /// <code>{
        ///   path: string, # Optional. Location of the document or folder
        ///   sourcePath: string, # Required. Location of the source document
        ///   createdDateTimeUtc: string (ISO 8601 Format), # Required. Operation created date time
        ///   lastActionDateTimeUtc: string (ISO 8601 Format), # Required. Date time in which the operation&apos;s status has been updated
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;Cancelled&quot; | &quot;Cancelling&quot; | &quot;ValidationFailed&quot;, # Required. List of possible statuses for job or document
        ///   to: string, # Required. To language
        ///   error: {
        ///     code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;ResourceNotFound&quot; | &quot;Unauthorized&quot; | &quot;RequestRateTooHigh&quot;, # Required. Enums containing high level error codes.
        ///     message: string, # Required. Gets high level error message.
        ///     target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///     innerError: {
        ///       code: string, # Required. Gets code error string.
        ///       message: string, # Required. Gets high level error message.
        ///       target: string, # Optional. Gets the source of the error. 
        /// For example it would be &quot;documents&quot; or &quot;document id&quot; in case of invalid document.
        ///       innerError: InnerTranslationError, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///     }, # Optional. New Inner Error format which conforms to Cognitive Services API Guidelines which is available at https://microsoft.sharepoint.com/%3Aw%3A/t/CognitiveServicesPMO/EUoytcrjuJdKpeOKIK_QRC8BPtUYQpKBi8JsWyeDMRsWlQ?e=CPq8ow.
        /// This contains required properties ErrorCode, message and optional properties target, details(key value pair), inner error(this can be nested).
        ///   }, # Optional. This contains an outer error with error code, message, details, target and an inner error with more descriptive details.
        ///   progress: number, # Required. Progress of the translation if available
        ///   id: DocumentStatusId, # Required. Document Id
        ///   characterCharged: number, # Optional. Character charged by the API
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDocumentsStatus(Guid id, int? top = null, int? skip = null, int? maxpagesize = null, IEnumerable<Guid> ids = null, IEnumerable<string> statuses = null, DateTimeOffset? createdDateTimeUtcStart = null, DateTimeOffset? createdDateTimeUtcEnd = null, IEnumerable<string> orderBy = null, RequestContext context = null)
        {
            return GetDocumentsStatusImplementation("DocumentTranslationClient.GetDocumentsStatus", id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
        }

        private Pageable<BinaryData> GetDocumentsStatusImplementation(string diagnosticsScopeName, Guid id, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDocumentsStatusRequest(id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context)
                        : CreateGetDocumentsStatusNextPageRequest(nextLink, id, top, skip, maxpagesize, ids, statuses, createdDateTimeUtcStart, createdDateTimeUtcEnd, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Submit a document translation request to the Document Translation service. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: &quot;application/*+json&quot; | &quot;application/json&quot; | &quot;text/json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call StartTranslationAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     inputs = new[] {
        ///         new {
        ///             source = new {
        ///                 sourceUrl = "<SourceInputSourceUrl>",
        ///                 filter = new {
        ///                     prefix = "<DocumentFilterPrefix>",
        ///                     suffix = "<DocumentFilterSuffix>",
        ///                 },
        ///                 language = "<SourceInputLanguage>",
        ///                 storageSource = "<AzureBlob>",
        ///             },
        ///             targets = new[] {
        ///                 new {
        ///                     targetUrl = "<TargetInputTargetUrl>",
        ///                     category = "<TargetInputCategory>",
        ///                     language = "<TargetInputLanguage>",
        ///                     glossaries = new[] {
        ///                         new {
        ///                             glossaryUrl = "<GlossaryUrl>",
        ///                             format = "<GlossaryFormat>",
        ///                             version = "<GlossaryVersion>",
        ///                             storageSource = "<AzureBlob>",
        ///                         }
        ///                     },
        ///                     storageSource = "<AzureBlob>",
        ///                 }
        ///             },
        ///             storageType = "<Folder>",
        ///         }
        ///     },
        /// };
        /// 
        /// var operation = await client.StartTranslationAsync(WaitUntil.Completed, RequestContent.Create(data), ContentType.ApplicationOctetStream);
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Use this API to submit a bulk (batch) translation request to the Document Translation service.
        /// Each request can contain multiple documents and must contain a source and destination container for each document.
        ///             
        /// The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath after the container name.
        ///             
        /// Glossaries / Translation memory can be included in the request and are applied by the service when the document is translated.
        ///             
        /// If the glossary is invalid or unreachable during translation, an error is indicated in the document status.
        /// If a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each target language must be unique.
        /// 
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>StartTranslationDetails</c>:
        /// <code>{
        ///   inputs: [
        ///     {
        ///       source: {
        ///         sourceUrl: string, # Required. Location of the folder / container or single file with your documents
        ///         filter: {
        ///           prefix: string, # Optional. A case-sensitive prefix string to filter documents in the source path for translation. 
        /// For example, when using a Azure storage blob Uri, use the prefix to restrict sub folders for translation.
        ///           suffix: string, # Optional. A case-sensitive suffix string to filter documents in the source path for translation. 
        /// This is most often use for file extensions
        ///         }, # Optional.
        ///         language: string, # Optional. Language code
        /// If none is specified, we will perform auto detect on the document
        ///         storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///       }, # Required. Source of the input documents
        ///       targets: [
        ///         {
        ///           targetUrl: string, # Required. Location of the folder / container with your documents
        ///           category: string, # Optional. Category / custom system for translation request
        ///           language: string, # Required. Target Language
        ///           glossaries: [
        ///             {
        ///               glossaryUrl: string, # Required. Location of the glossary. 
        /// We will use the file extension to extract the formatting if the format parameter is not supplied.
        /// 
        /// If the translation language pair is not present in the glossary, it will not be applied
        ///               format: string, # Required. Format
        ///               version: string, # Optional. Optional Version.  If not specified, default is used.
        ///               storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///             }
        ///           ], # Optional. List of Glossary
        ///           storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///         }
        ///       ], # Required. Location of the destination for the output
        ///       storageType: &quot;Folder&quot; | &quot;File&quot;, # Optional. Storage type of the input documents source string
        ///     }
        ///   ], # Required. The input list of documents or folders containing documents
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation> StartTranslationAsync(WaitUntil waitUntil, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.StartTranslation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartTranslationRequest(content, contentType, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "DocumentTranslationClient.StartTranslation", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Submit a document translation request to the Document Translation service. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: &quot;application/*+json&quot; | &quot;application/json&quot; | &quot;text/json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call StartTranslation with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var client = new DocumentTranslationClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     inputs = new[] {
        ///         new {
        ///             source = new {
        ///                 sourceUrl = "<SourceInputSourceUrl>",
        ///                 filter = new {
        ///                     prefix = "<DocumentFilterPrefix>",
        ///                     suffix = "<DocumentFilterSuffix>",
        ///                 },
        ///                 language = "<SourceInputLanguage>",
        ///                 storageSource = "<AzureBlob>",
        ///             },
        ///             targets = new[] {
        ///                 new {
        ///                     targetUrl = "<TargetInputTargetUrl>",
        ///                     category = "<TargetInputCategory>",
        ///                     language = "<TargetInputLanguage>",
        ///                     glossaries = new[] {
        ///                         new {
        ///                             glossaryUrl = "<GlossaryUrl>",
        ///                             format = "<GlossaryFormat>",
        ///                             version = "<GlossaryVersion>",
        ///                             storageSource = "<AzureBlob>",
        ///                         }
        ///                     },
        ///                     storageSource = "<AzureBlob>",
        ///                 }
        ///             },
        ///             storageType = "<Folder>",
        ///         }
        ///     },
        /// };
        /// 
        /// var operation = client.StartTranslation(WaitUntil.Completed, RequestContent.Create(data), ContentType.ApplicationOctetStream);
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Use this API to submit a bulk (batch) translation request to the Document Translation service.
        /// Each request can contain multiple documents and must contain a source and destination container for each document.
        ///             
        /// The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath after the container name.
        ///             
        /// Glossaries / Translation memory can be included in the request and are applied by the service when the document is translated.
        ///             
        /// If the glossary is invalid or unreachable during translation, an error is indicated in the document status.
        /// If a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each target language must be unique.
        /// 
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>StartTranslationDetails</c>:
        /// <code>{
        ///   inputs: [
        ///     {
        ///       source: {
        ///         sourceUrl: string, # Required. Location of the folder / container or single file with your documents
        ///         filter: {
        ///           prefix: string, # Optional. A case-sensitive prefix string to filter documents in the source path for translation. 
        /// For example, when using a Azure storage blob Uri, use the prefix to restrict sub folders for translation.
        ///           suffix: string, # Optional. A case-sensitive suffix string to filter documents in the source path for translation. 
        /// This is most often use for file extensions
        ///         }, # Optional.
        ///         language: string, # Optional. Language code
        /// If none is specified, we will perform auto detect on the document
        ///         storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///       }, # Required. Source of the input documents
        ///       targets: [
        ///         {
        ///           targetUrl: string, # Required. Location of the folder / container with your documents
        ///           category: string, # Optional. Category / custom system for translation request
        ///           language: string, # Required. Target Language
        ///           glossaries: [
        ///             {
        ///               glossaryUrl: string, # Required. Location of the glossary. 
        /// We will use the file extension to extract the formatting if the format parameter is not supplied.
        /// 
        /// If the translation language pair is not present in the glossary, it will not be applied
        ///               format: string, # Required. Format
        ///               version: string, # Optional. Optional Version.  If not specified, default is used.
        ///               storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///             }
        ///           ], # Optional. List of Glossary
        ///           storageSource: &quot;AzureBlob&quot;, # Optional. Storage Source
        ///         }
        ///       ], # Required. Location of the destination for the output
        ///       storageType: &quot;Folder&quot; | &quot;File&quot;, # Optional. Storage type of the input documents source string
        ///     }
        ///   ], # Required. The input list of documents or folders containing documents
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation StartTranslation(WaitUntil waitUntil, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DocumentTranslationClient.StartTranslation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartTranslationRequest(content, contentType, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "DocumentTranslationClient.StartTranslation", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateStartTranslationRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTranslationsStatusRequest(int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches", false);
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            if (ids != null)
            {
                uri.AppendQueryDelimited("ids", ids, ",", true);
            }
            if (statuses != null)
            {
                uri.AppendQueryDelimited("statuses", statuses, ",", true);
            }
            if (createdDateTimeUtcStart != null)
            {
                uri.AppendQuery("createdDateTimeUtcStart", createdDateTimeUtcStart.Value, "O", true);
            }
            if (createdDateTimeUtcEnd != null)
            {
                uri.AppendQuery("createdDateTimeUtcEnd", createdDateTimeUtcEnd.Value, "O", true);
            }
            if (orderBy != null)
            {
                uri.AppendQueryDelimited("$orderBy", orderBy, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDocumentStatusRequest(Guid id, Guid documentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/documents/", false);
            uri.AppendPath(documentId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTranslationStatusRequest(Guid id, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches/", false);
            uri.AppendPath(id, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelTranslationRequest(Guid id, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches/", false);
            uri.AppendPath(id, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDocumentsStatusRequest(Guid id, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/batches/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/documents", false);
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            if (ids != null)
            {
                uri.AppendQueryDelimited("ids", ids, ",", true);
            }
            if (statuses != null)
            {
                uri.AppendQueryDelimited("statuses", statuses, ",", true);
            }
            if (createdDateTimeUtcStart != null)
            {
                uri.AppendQuery("createdDateTimeUtcStart", createdDateTimeUtcStart.Value, "O", true);
            }
            if (createdDateTimeUtcEnd != null)
            {
                uri.AppendQuery("createdDateTimeUtcEnd", createdDateTimeUtcEnd.Value, "O", true);
            }
            if (orderBy != null)
            {
                uri.AppendQueryDelimited("$orderBy", orderBy, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedDocumentFormatsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/documents/formats", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedGlossaryFormatsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/glossaries/formats", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedStorageSourcesRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendPath("/storagesources", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTranslationsStatusNextPageRequest(string nextLink, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDocumentsStatusNextPageRequest(string nextLink, Guid id, int? top, int? skip, int? maxpagesize, IEnumerable<Guid> ids, IEnumerable<string> statuses, DateTimeOffset? createdDateTimeUtcStart, DateTimeOffset? createdDateTimeUtcEnd, IEnumerable<string> orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendRaw("/translator/text/batch/v1.0-preview.1", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
