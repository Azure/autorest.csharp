# Quick Start

Azure services define their web APIs using [swagger files](https://github.com/azure/azure-rest-api-specs).

To binding those into an SDK, Azure SDK uses [Autorest](https://github.com/Azure/autorest) to parse the swagger definitions into boilerplate networking and serialization code. 

As the Azure SDK has multiple supported languages, Autorest uses plugins for each languages backend. This repository is the C# platform support plugin. 

During autorest execution, the plugin is passed a YAML intermediate representation (IR) of the API definition.

[Example YAML IR](https://github.com/Azure/autorest.csharp/blob/feature/v3/test/TestProjects/AdditionalPropertiesEx/CodeModel.yaml)

The plugin is normally called via JSON RPC but there is a standalone mode that can process the intermediate yaml from disk.

autorest uses a markdown based configuration system (autorest.md) to determine what swagger files to process. 

The C# backend also has an associated csproj next to autorest.md that is processed for customizations and complication of output.

# History

There are two “tracks" of generated Azure SDK codegen with some history behind them

- Track 1 refers to Azure bindings before the Azure SDK team was formed to standardize bindings
  - C# uses v2 (master) branch of autorest.csharp
  - Some of these bindings was solely the autogenerated code, and were not always easy to use
- Track 2 is the modern set of bindings reviewed by Arch board and consistent across product/language
   - C# uses v3 branch of autorest.csharp
   - Many of these leverage the autoget output internally but provide nicer hand written layer on top
   - [Generated code example](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/tables/Azure.Data.Tables/src/TableClient.cs)

# Internals

Autorest first take a pass at processing the swagger input files, and then hands the output to a “Modeler 4” pipeline inside auto rest which can encode patterns useful on all language backends

Example: Many APIs have paging, where a request will only return the first 100, and you have to ask for additional "pages" of 100 one at a time

Today that pipeline lives in a [separate repository]( https://github.com/Azure/autorest.modelerfour/) but very likely to end up in [autorest proper]( https://github.com/Azure/autorest) long term.

The c# autorest plugin/generator has three major components: 

- A model layer that builds up a representation of the desired output based upon the YAML IR 
  - These are C# specific modelling decisisons
  - The input project can customize the generated code by having partial classes defined. Those are read by the C# backend and modify the generated code.
  - Generated code is output in a Generated folder next to the csproj
- A rendering layer that uses CodeWriter to output C# code, which is injected into the 
- A roslyn simplification pass processes that generated output to make formatting and namespaces look more natural

One important part of codegen is serialization.
- Models get json serialization
- Requests also get serialization (so they can be sent over HTTPRequest)

There are a number of “shared” files that get included with the generated code implicitly into the final project
- All are internal visibility, and let us iterate quickly upon their API surface
- Long term the goal should be to upstream to azure core

# Integration with Azure SDK Repository

Landing a change in autorest.csharp will open a PR against azure-sdk-for-net with every project’s generated code staged for review.

Along with this, it also bumps of the generator to the new version. 

This bump is done [here](https://github.com/Azure/azure-sdk-for-net/blob/master/eng/Packages.Data.props).

The generator is shipped as a nuget. 

This way, every binding stays in lockstep with the current generator

# Tooling

Generate.ps1 is autorest.csharp is your first stop to test changes across many swagger definations and samples
- -fast option skips Swagger -> YAML IL step. Much faster when only making codegen changes
- -fast SWAGGER_NAME to run only one case
- One important note is that Generate.ps1 runs logic similar to /t:GenerateCode but does not use it directly 

From the azure-sdk-for-net side, you can run a msbuild target to regenerate code for a specific project you are working on
- dotnet build /t:GenerateCode
- This executes [these targets](https://github.com/Azure/autorest.csharp/blob/feature/v3/src/AutoRest.CSharp.V3/build/CodeGeneration.targets).

# Testing

[autorest.testserver](http://github.com/Azure/autorest.testserver/) provides a platform for automated testing of the code generators. 

It packages a bunch of test swagger files, along with a “mock” nodejs server. 

The swagger files are compiled, and then run, which pings the mock server (to verify behavior). This tests both the Modeler 4 and language specific codegen. 

## Testing generator changes against Azure SDK itself

These instructions are only a general outline, see [the script](https://github.com/Azure/autorest.csharp/blob/feature/v3/eng/UpdateAzureSdkForNet.ps1) for details:

- Use dotnet pack to package up a version of the generator
- dotnet pack -o directory
- Copy that nuget to your local nuget source
- Update package.props
- dotnet restore -S directory 