// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using lro.Models;

namespace lro
{
    public partial class LROsClient
    {
        private readonly ClientDiagnostics clientDiagnostics;
        private readonly HttpPipeline pipeline;
        internal LROsRestClient RestClient { get; }
        /// <summary> Initializes a new instance of LROsClient for mocking. </summary>
        protected LROsClient()
        {
        }
        /// <summary> Initializes a new instance of LROsClient. </summary>
        internal LROsClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string host = "http://localhost:3000")
        {
            RestClient = new LROsRestClient(clientDiagnostics, pipeline, host);
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut200Succeeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put200SucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut200SucceededAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put200SucceededOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut200Succeeded(originalResponse, () => RestClient.CreatePut200SucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut200Succeeded(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put200SucceededOperation(product, cancellationToken);
            return CreatePut200Succeeded(originalResponse, () => RestClient.CreatePut200SucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut200SucceededNoState(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put200SucceededNoStateOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut200SucceededNoStateAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put200SucceededNoStateOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut200SucceededNoState(originalResponse, () => RestClient.CreatePut200SucceededNoStateOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut200SucceededNoState(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put200SucceededNoStateOperation(product, cancellationToken);
            return CreatePut200SucceededNoState(originalResponse, () => RestClient.CreatePut200SucceededNoStateOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn&apos;t contains ProvisioningState. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut202Retry200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put202Retry200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn&apos;t contains ProvisioningState. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut202Retry200Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put202Retry200OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut202Retry200(originalResponse, () => RestClient.CreatePut202Retry200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn&apos;t contains ProvisioningState. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut202Retry200(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put202Retry200Operation(product, cancellationToken);
            return CreatePut202Retry200(originalResponse, () => RestClient.CreatePut202Retry200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut201CreatingSucceeded200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put201CreatingSucceeded200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut201CreatingSucceeded200Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put201CreatingSucceeded200OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut201CreatingSucceeded200(originalResponse, () => RestClient.CreatePut201CreatingSucceeded200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut201CreatingSucceeded200(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put201CreatingSucceeded200Operation(product, cancellationToken);
            return CreatePut201CreatingSucceeded200(originalResponse, () => RestClient.CreatePut201CreatingSucceeded200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut200UpdatingSucceeded204(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put200UpdatingSucceeded204Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut200UpdatingSucceeded204Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put200UpdatingSucceeded204OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut200UpdatingSucceeded204(originalResponse, () => RestClient.CreatePut200UpdatingSucceeded204OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut200UpdatingSucceeded204(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put200UpdatingSucceeded204Operation(product, cancellationToken);
            return CreatePut200UpdatingSucceeded204(originalResponse, () => RestClient.CreatePut200UpdatingSucceeded204OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut201CreatingFailed200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put201CreatingFailed200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut201CreatingFailed200Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put201CreatingFailed200OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut201CreatingFailed200(originalResponse, () => RestClient.CreatePut201CreatingFailed200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut201CreatingFailed200(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put201CreatingFailed200Operation(product, cancellationToken);
            return CreatePut201CreatingFailed200(originalResponse, () => RestClient.CreatePut201CreatingFailed200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePut200Acceptedcanceled200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.Put200Acceptedcanceled200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPut200Acceptedcanceled200Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Put200Acceptedcanceled200OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePut200Acceptedcanceled200(originalResponse, () => RestClient.CreatePut200Acceptedcanceled200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPut200Acceptedcanceled200(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Put200Acceptedcanceled200Operation(product, cancellationToken);
            return CreatePut200Acceptedcanceled200(originalResponse, () => RestClient.CreatePut200Acceptedcanceled200OperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutNoHeaderInRetry(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutNoHeaderInRetryOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutNoHeaderInRetryAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutNoHeaderInRetryOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutNoHeaderInRetry(originalResponse, () => RestClient.CreatePutNoHeaderInRetryOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutNoHeaderInRetry(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutNoHeaderInRetryOperation(product, cancellationToken);
            return CreatePutNoHeaderInRetry(originalResponse, () => RestClient.CreatePutNoHeaderInRetryOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutAsyncRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutAsyncRetrySucceededAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncRetrySucceededOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncRetrySucceeded(originalResponse, () => RestClient.CreatePutAsyncRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutAsyncRetrySucceeded(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncRetrySucceededOperation(product, cancellationToken);
            return CreatePutAsyncRetrySucceeded(originalResponse, () => RestClient.CreatePutAsyncRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutAsyncNoRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncNoRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutAsyncNoRetrySucceededAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncNoRetrySucceededOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreatePutAsyncNoRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutAsyncNoRetrySucceeded(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncNoRetrySucceededOperation(product, cancellationToken);
            return CreatePutAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreatePutAsyncNoRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutAsyncRetryFailed(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncRetryFailedOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutAsyncRetryFailedAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncRetryFailedOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncRetryFailed(originalResponse, () => RestClient.CreatePutAsyncRetryFailedOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutAsyncRetryFailed(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncRetryFailedOperation(product, cancellationToken);
            return CreatePutAsyncRetryFailed(originalResponse, () => RestClient.CreatePutAsyncRetryFailedOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutAsyncNoRetrycanceled(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncNoRetrycanceledOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutAsyncNoRetrycanceledAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncNoRetrycanceledOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncNoRetrycanceled(originalResponse, () => RestClient.CreatePutAsyncNoRetrycanceledOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutAsyncNoRetrycanceled(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncNoRetrycanceledOperation(product, cancellationToken);
            return CreatePutAsyncNoRetrycanceled(originalResponse, () => RestClient.CreatePutAsyncNoRetrycanceledOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePutAsyncNoHeaderInRetry(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncNoHeaderInRetryOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPutAsyncNoHeaderInRetryAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncNoHeaderInRetryOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncNoHeaderInRetry(originalResponse, () => RestClient.CreatePutAsyncNoHeaderInRetryOperationRequest(product));
        }
        /// <summary> Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPutAsyncNoHeaderInRetry(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncNoHeaderInRetryOperation(product, cancellationToken);
            return CreatePutAsyncNoHeaderInRetry(originalResponse, () => RestClient.CreatePutAsyncNoHeaderInRetryOperationRequest(product));
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Sku> CreatePutNonResource(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutNonResourceOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="sku"> sku to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Sku>> StartPutNonResourceAsync(Sku sku, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutNonResourceOperationAsync(sku, cancellationToken).ConfigureAwait(false);
            return CreatePutNonResource(originalResponse, () => RestClient.CreatePutNonResourceOperationRequest(sku));
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="sku"> sku to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Sku> StartPutNonResource(Sku sku, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutNonResourceOperation(sku, cancellationToken);
            return CreatePutNonResource(originalResponse, () => RestClient.CreatePutNonResourceOperationRequest(sku));
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Sku> CreatePutAsyncNonResource(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncNonResourceOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="sku"> sku to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Sku>> StartPutAsyncNonResourceAsync(Sku sku, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncNonResourceOperationAsync(sku, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncNonResource(originalResponse, () => RestClient.CreatePutAsyncNonResourceOperationRequest(sku));
        }
        /// <summary> Long running put request with non resource. </summary>
        /// <param name="sku"> sku to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Sku> StartPutAsyncNonResource(Sku sku, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncNonResourceOperation(sku, cancellationToken);
            return CreatePutAsyncNonResource(originalResponse, () => RestClient.CreatePutAsyncNonResourceOperationRequest(sku));
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<SubProduct> CreatePutSubResource(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutSubResourceOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = SubProduct.DeserializeSubProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = SubProduct.DeserializeSubProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="product"> Sub Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<SubProduct>> StartPutSubResourceAsync(SubProduct product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutSubResourceOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutSubResource(originalResponse, () => RestClient.CreatePutSubResourceOperationRequest(product));
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="product"> Sub Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<SubProduct> StartPutSubResource(SubProduct product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutSubResourceOperation(product, cancellationToken);
            return CreatePutSubResource(originalResponse, () => RestClient.CreatePutSubResourceOperationRequest(product));
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<SubProduct> CreatePutAsyncSubResource(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Put, "LROsClient.PutAsyncSubResourceOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = SubProduct.DeserializeSubProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = SubProduct.DeserializeSubProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="product"> Sub Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<SubProduct>> StartPutAsyncSubResourceAsync(SubProduct product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PutAsyncSubResourceOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePutAsyncSubResource(originalResponse, () => RestClient.CreatePutAsyncSubResourceOperationRequest(product));
        }
        /// <summary> Long running put request with sub resource. </summary>
        /// <param name="product"> Sub Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<SubProduct> StartPutAsyncSubResource(SubProduct product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PutAsyncSubResourceOperation(product, cancellationToken);
            return CreatePutAsyncSubResource(originalResponse, () => RestClient.CreatePutAsyncSubResourceOperationRequest(product));
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreateDeleteProvisioning202Accepted200Succeeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteProvisioning202Accepted200SucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartDeleteProvisioning202Accepted200SucceededAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteProvisioning202Accepted200SucceededOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteProvisioning202Accepted200Succeeded(originalResponse, () => RestClient.CreateDeleteProvisioning202Accepted200SucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartDeleteProvisioning202Accepted200Succeeded(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteProvisioning202Accepted200SucceededOperation(cancellationToken);
            return CreateDeleteProvisioning202Accepted200Succeeded(originalResponse, () => RestClient.CreateDeleteProvisioning202Accepted200SucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreateDeleteProvisioning202DeletingFailed200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteProvisioning202DeletingFailed200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartDeleteProvisioning202DeletingFailed200Async(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteProvisioning202DeletingFailed200OperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteProvisioning202DeletingFailed200(originalResponse, () => RestClient.CreateDeleteProvisioning202DeletingFailed200OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartDeleteProvisioning202DeletingFailed200(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteProvisioning202DeletingFailed200Operation(cancellationToken);
            return CreateDeleteProvisioning202DeletingFailed200(originalResponse, () => RestClient.CreateDeleteProvisioning202DeletingFailed200OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreateDeleteProvisioning202Deletingcanceled200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteProvisioning202Deletingcanceled200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartDeleteProvisioning202Deletingcanceled200Async(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteProvisioning202Deletingcanceled200OperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteProvisioning202Deletingcanceled200(originalResponse, () => RestClient.CreateDeleteProvisioning202Deletingcanceled200OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartDeleteProvisioning202Deletingcanceled200(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteProvisioning202Deletingcanceled200Operation(cancellationToken);
            return CreateDeleteProvisioning202Deletingcanceled200(originalResponse, () => RestClient.CreateDeleteProvisioning202Deletingcanceled200OperationRequest());
        }
        /// <summary> Long running delete succeeds and returns right away. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDelete204Succeeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.Delete204SucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete succeeds and returns right away. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDelete204SucceededAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Delete204SucceededOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDelete204Succeeded(originalResponse, () => RestClient.CreateDelete204SucceededOperationRequest());
        }
        /// <summary> Long running delete succeeds and returns right away. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDelete204Succeeded(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Delete204SucceededOperation(cancellationToken);
            return CreateDelete204Succeeded(originalResponse, () => RestClient.CreateDelete204SucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreateDelete202Retry200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.Delete202Retry200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartDelete202Retry200Async(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Delete202Retry200OperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDelete202Retry200(originalResponse, () => RestClient.CreateDelete202Retry200OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartDelete202Retry200(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Delete202Retry200Operation(cancellationToken);
            return CreateDelete202Retry200(originalResponse, () => RestClient.CreateDelete202Retry200OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreateDelete202NoRetry204(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.Delete202NoRetry204Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartDelete202NoRetry204Async(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Delete202NoRetry204OperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDelete202NoRetry204(originalResponse, () => RestClient.CreateDelete202NoRetry204OperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartDelete202NoRetry204(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Delete202NoRetry204Operation(cancellationToken);
            return CreateDelete202NoRetry204(originalResponse, () => RestClient.CreateDelete202NoRetry204OperationRequest());
        }
        /// <summary> Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteNoHeaderInRetry(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteNoHeaderInRetryOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteNoHeaderInRetryAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteNoHeaderInRetryOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteNoHeaderInRetry(originalResponse, () => RestClient.CreateDeleteNoHeaderInRetryOperationRequest());
        }
        /// <summary> Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteNoHeaderInRetry(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteNoHeaderInRetryOperation(cancellationToken);
            return CreateDeleteNoHeaderInRetry(originalResponse, () => RestClient.CreateDeleteNoHeaderInRetryOperationRequest());
        }
        /// <summary> Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAsyncNoHeaderInRetry(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteAsyncNoHeaderInRetryOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsyncNoHeaderInRetryAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteAsyncNoHeaderInRetryOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteAsyncNoHeaderInRetry(originalResponse, () => RestClient.CreateDeleteAsyncNoHeaderInRetryOperationRequest());
        }
        /// <summary> Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAsyncNoHeaderInRetry(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteAsyncNoHeaderInRetryOperation(cancellationToken);
            return CreateDeleteAsyncNoHeaderInRetry(originalResponse, () => RestClient.CreateDeleteAsyncNoHeaderInRetryOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAsyncRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteAsyncRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsyncRetrySucceededAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteAsyncRetrySucceededOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteAsyncRetrySucceeded(originalResponse, () => RestClient.CreateDeleteAsyncRetrySucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAsyncRetrySucceeded(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteAsyncRetrySucceededOperation(cancellationToken);
            return CreateDeleteAsyncRetrySucceeded(originalResponse, () => RestClient.CreateDeleteAsyncRetrySucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAsyncNoRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteAsyncNoRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsyncNoRetrySucceededAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteAsyncNoRetrySucceededOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreateDeleteAsyncNoRetrySucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAsyncNoRetrySucceeded(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteAsyncNoRetrySucceededOperation(cancellationToken);
            return CreateDeleteAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreateDeleteAsyncNoRetrySucceededOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAsyncRetryFailed(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteAsyncRetryFailedOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsyncRetryFailedAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteAsyncRetryFailedOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteAsyncRetryFailed(originalResponse, () => RestClient.CreateDeleteAsyncRetryFailedOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAsyncRetryFailed(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteAsyncRetryFailedOperation(cancellationToken);
            return CreateDeleteAsyncRetryFailed(originalResponse, () => RestClient.CreateDeleteAsyncRetryFailedOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAsyncRetrycanceled(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Delete, "LROsClient.DeleteAsyncRetrycanceledOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsyncRetrycanceledAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.DeleteAsyncRetrycanceledOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreateDeleteAsyncRetrycanceled(originalResponse, () => RestClient.CreateDeleteAsyncRetrycanceledOperationRequest());
        }
        /// <summary> Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAsyncRetrycanceled(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.DeleteAsyncRetrycanceledOperation(cancellationToken);
            return CreateDeleteAsyncRetrycanceled(originalResponse, () => RestClient.CreateDeleteAsyncRetrycanceledOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header. Poll returns a 200 with a response body after success. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Sku> CreatePost200WithPayload(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.Post200WithPayloadOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Sku.DeserializeSku(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header. Poll returns a 200 with a response body after success. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Sku>> StartPost200WithPayloadAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Post200WithPayloadOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreatePost200WithPayload(originalResponse, () => RestClient.CreatePost200WithPayloadOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header. Poll returns a 200 with a response body after success. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Sku> StartPost200WithPayload(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Post200WithPayloadOperation(cancellationToken);
            return CreatePost200WithPayload(originalResponse, () => RestClient.CreatePost200WithPayloadOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; and &apos;Retry-After&apos; headers, Polls return a 200 with a response body after success. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreatePost202Retry200(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.Post202Retry200Operation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; and &apos;Retry-After&apos; headers, Polls return a 200 with a response body after success. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartPost202Retry200Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Post202Retry200OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePost202Retry200(originalResponse, () => RestClient.CreatePost202Retry200OperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; and &apos;Retry-After&apos; headers, Polls return a 200 with a response body after success. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartPost202Retry200(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Post202Retry200Operation(product, cancellationToken);
            return CreatePost202Retry200(originalResponse, () => RestClient.CreatePost202Retry200OperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header, 204 with noresponse body after success. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePost202NoRetry204(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.Post202NoRetry204Operation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header, 204 with noresponse body after success. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPost202NoRetry204Async(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.Post202NoRetry204OperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePost202NoRetry204(originalResponse, () => RestClient.CreatePost202NoRetry204OperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with &apos;Location&apos; header, 204 with noresponse body after success. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPost202NoRetry204(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.Post202NoRetry204Operation(product, cancellationToken);
            return CreatePost202NoRetry204(originalResponse, () => RestClient.CreatePost202NoRetry204OperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should poll Location to get the final object. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePostDoubleHeadersFinalLocationGet(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostDoubleHeadersFinalLocationGetOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should poll Location to get the final object. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPostDoubleHeadersFinalLocationGetAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostDoubleHeadersFinalLocationGetOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreatePostDoubleHeadersFinalLocationGet(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalLocationGetOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should poll Location to get the final object. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPostDoubleHeadersFinalLocationGet(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostDoubleHeadersFinalLocationGetOperation(cancellationToken);
            return CreatePostDoubleHeadersFinalLocationGet(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalLocationGetOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePostDoubleHeadersFinalAzureHeaderGet(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostDoubleHeadersFinalAzureHeaderGetOperation", OperationFinalStateVia.AzureAsyncOperation, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPostDoubleHeadersFinalAzureHeaderGetAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostDoubleHeadersFinalAzureHeaderGetOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreatePostDoubleHeadersFinalAzureHeaderGet(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalAzureHeaderGetOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPostDoubleHeadersFinalAzureHeaderGet(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostDoubleHeadersFinalAzureHeaderGetOperation(cancellationToken);
            return CreatePostDoubleHeadersFinalAzureHeaderGet(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalAzureHeaderGetOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object if you support initial Autorest behavior. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePostDoubleHeadersFinalAzureHeaderGetDefault(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostDoubleHeadersFinalAzureHeaderGetDefaultOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object if you support initial Autorest behavior. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPostDoubleHeadersFinalAzureHeaderGetDefaultAsync(CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostDoubleHeadersFinalAzureHeaderGetDefaultOperationAsync(cancellationToken).ConfigureAwait(false);
            return CreatePostDoubleHeadersFinalAzureHeaderGetDefault(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalAzureHeaderGetDefaultOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it&apos;s success. Should NOT poll Location to get the final object if you support initial Autorest behavior. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPostDoubleHeadersFinalAzureHeaderGetDefault(CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostDoubleHeadersFinalAzureHeaderGetDefaultOperation(cancellationToken);
            return CreatePostDoubleHeadersFinalAzureHeaderGetDefault(originalResponse, () => RestClient.CreatePostDoubleHeadersFinalAzureHeaderGetDefaultOperationRequest());
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePostAsyncRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostAsyncRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPostAsyncRetrySucceededAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostAsyncRetrySucceededOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePostAsyncRetrySucceeded(originalResponse, () => RestClient.CreatePostAsyncRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPostAsyncRetrySucceeded(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostAsyncRetrySucceededOperation(product, cancellationToken);
            return CreatePostAsyncRetrySucceeded(originalResponse, () => RestClient.CreatePostAsyncRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Product> CreatePostAsyncNoRetrySucceeded(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostAsyncNoRetrySucceededOperation", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                var value = Product.DeserializeProduct(document.RootElement);
                return value;
            });
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Product>> StartPostAsyncNoRetrySucceededAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostAsyncNoRetrySucceededOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePostAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreatePostAsyncNoRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Product> StartPostAsyncNoRetrySucceeded(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostAsyncNoRetrySucceededOperation(product, cancellationToken);
            return CreatePostAsyncNoRetrySucceeded(originalResponse, () => RestClient.CreatePostAsyncNoRetrySucceededOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreatePostAsyncRetryFailed(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostAsyncRetryFailedOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartPostAsyncRetryFailedAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostAsyncRetryFailedOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePostAsyncRetryFailed(originalResponse, () => RestClient.CreatePostAsyncRetryFailedOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartPostAsyncRetryFailed(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostAsyncRetryFailedOperation(product, cancellationToken);
            return CreatePostAsyncRetryFailed(originalResponse, () => RestClient.CreatePostAsyncRetryFailedOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreatePostAsyncRetrycanceled(Response originalResponse, Func<HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(pipeline, clientDiagnostics, originalResponse, RequestMethod.Post, "LROsClient.PostAsyncRetrycanceledOperation", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartPostAsyncRetrycanceledAsync(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = await RestClient.PostAsyncRetrycanceledOperationAsync(product, cancellationToken).ConfigureAwait(false);
            return CreatePostAsyncRetrycanceled(originalResponse, () => RestClient.CreatePostAsyncRetrycanceledOperationRequest(product));
        }
        /// <summary> Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status. </summary>
        /// <param name="product"> Product to put. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartPostAsyncRetrycanceled(Product product, CancellationToken cancellationToken = default)
        {
            var originalResponse = RestClient.PostAsyncRetrycanceledOperation(product, cancellationToken);
            return CreatePostAsyncRetrycanceled(originalResponse, () => RestClient.CreatePostAsyncRetrycanceledOperationRequest(product));
        }
    }
}
