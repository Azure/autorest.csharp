// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ServiceModel.Rest;
using System.ServiceModel.Rest.Core;
using System.ServiceModel.Rest.Core.Pipeline;
using System.ServiceModel.Rest.Internal;
using System.Threading;
using System.Threading.Tasks;
using OpenAI.Models;

namespace OpenAI
{
    // Data plane generated client.
    /// <summary> The OpenAI service client. </summary>
    public partial class OpenAIClient
    {
        private const string AuthorizationHeader = "Authorization";
        private readonly KeyCredential _keyCredential;
        private const string AuthorizationApiKeyPrefix = "Bearer";
        private readonly MessagePipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal TelemetrySource ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual MessagePipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of OpenAIClient for mocking. </summary>
        protected OpenAIClient()
        {
        }

        /// <summary> Initializes a new instance of OpenAIClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="credential"/> is null. </exception>
        public OpenAIClient(KeyCredential credential) : this(new Uri("https://api.openai.com/v1"), credential, new OpenAIClientOptions())
        {
        }

        /// <summary> Initializes a new instance of OpenAIClient. </summary>
        /// <param name="endpoint"> OpenAI Endpoint. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public OpenAIClient(Uri endpoint, KeyCredential credential, OpenAIClientOptions options)
        {
            ClientUtilities.AssertNotNull(endpoint, nameof(endpoint));
            ClientUtilities.AssertNotNull(credential, nameof(credential));
            options ??= new OpenAIClientOptions();

            ClientDiagnostics = new TelemetrySource(options, true);
            _keyCredential = credential;
            _pipeline = MessagePipeline.Create(options, new IPipelinePolicy<PipelineMessage>[] { new KeyCredentialPolicy(_keyCredential, AuthorizationHeader, AuthorizationApiKeyPrefix) }, Array.Empty<IPipelinePolicy<PipelineMessage>>());
            _endpoint = endpoint;
        }

        /// <summary> Transcribes audio into the input language. </summary>
        /// <param name="audio"> The CreateTranscriptionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="audio"/> is null. </exception>
        public virtual async Task<Result<CreateTranscriptionResponse>> CreateTranscriptionAsync(CreateTranscriptionRequest audio, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(audio, nameof(audio));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = audio.ToRequestBody();
            Result result = await CreateTranscriptionAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateTranscriptionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Transcribes audio into the input language. </summary>
        /// <param name="audio"> The CreateTranscriptionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="audio"/> is null. </exception>
        public virtual Result<CreateTranscriptionResponse> CreateTranscription(CreateTranscriptionRequest audio, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(audio, nameof(audio));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = audio.ToRequestBody();
            Result result = CreateTranscription(content, context);
            return Result.FromValue(CreateTranscriptionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Transcribes audio into the input language.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTranscriptionAsync(CreateTranscriptionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateTranscriptionAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateTranscription");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateTranscriptionRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Transcribes audio into the input language.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTranscription(CreateTranscriptionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateTranscription(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateTranscription");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateTranscriptionRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Transcribes audio into the input language. </summary>
        /// <param name="audio"> The CreateTranslationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="audio"/> is null. </exception>
        public virtual async Task<Result<CreateTranslationResponse>> CreateTranslationAsync(CreateTranslationRequest audio, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(audio, nameof(audio));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = audio.ToRequestBody();
            Result result = await CreateTranslationAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateTranslationResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Transcribes audio into the input language. </summary>
        /// <param name="audio"> The CreateTranslationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="audio"/> is null. </exception>
        public virtual Result<CreateTranslationResponse> CreateTranslation(CreateTranslationRequest audio, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(audio, nameof(audio));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = audio.ToRequestBody();
            Result result = CreateTranslation(content, context);
            return Result.FromValue(CreateTranslationResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Transcribes audio into the input language.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTranslationAsync(CreateTranslationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateTranslationAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateTranslation");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateTranslationRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Transcribes audio into the input language.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTranslation(CreateTranslationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateTranslation(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateTranslation");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateTranslationRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <param name="createChatCompletionRequest"> The CreateChatCompletionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createChatCompletionRequest"/> is null. </exception>
        public virtual async Task<Result<CreateChatCompletionResponse>> CreateChatCompletionAsync(CreateChatCompletionRequest createChatCompletionRequest, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(createChatCompletionRequest, nameof(createChatCompletionRequest));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = createChatCompletionRequest.ToRequestBody();
            Result result = await CreateChatCompletionAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateChatCompletionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <param name="createChatCompletionRequest"> The CreateChatCompletionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createChatCompletionRequest"/> is null. </exception>
        public virtual Result<CreateChatCompletionResponse> CreateChatCompletion(CreateChatCompletionRequest createChatCompletionRequest, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(createChatCompletionRequest, nameof(createChatCompletionRequest));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = createChatCompletionRequest.ToRequestBody();
            Result result = CreateChatCompletion(content, context);
            return Result.FromValue(CreateChatCompletionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateChatCompletionAsync(CreateChatCompletionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateChatCompletionAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateChatCompletion");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateChatCompletionRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateChatCompletion(CreateChatCompletionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateChatCompletion(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateChatCompletion");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateChatCompletionRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the
        /// fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// </summary>
        /// <param name="job"> The CreateFineTuningJobRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="job"/> is null. </exception>
        public virtual async Task<Result<FineTuningJob>> CreateFineTuningJobAsync(CreateFineTuningJobRequest job, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(job, nameof(job));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = job.ToRequestBody();
            Result result = await CreateFineTuningJobAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the
        /// fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// </summary>
        /// <param name="job"> The CreateFineTuningJobRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="job"/> is null. </exception>
        public virtual Result<FineTuningJob> CreateFineTuningJob(CreateFineTuningJobRequest job, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(job, nameof(job));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = job.ToRequestBody();
            Result result = CreateFineTuningJob(content, context);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the
        /// fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFineTuningJobAsync(CreateFineTuningJobRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateFineTuningJobAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFineTuningJobRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the
        /// fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFineTuningJob(CreateFineTuningJobRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateFineTuningJob(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFineTuningJobRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <param name="after"> Identifier for the last job from the previous pagination request. </param>
        /// <param name="limit"> Number of fine-tuning jobs to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Result<ListPaginatedFineTuningJobsResponse>> GetPaginatedFineTuningJobsAsync(string after = null, long? limit = null, CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetPaginatedFineTuningJobsAsync(after, limit, context).ConfigureAwait(false);
            return Result.FromValue(ListPaginatedFineTuningJobsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <param name="after"> Identifier for the last job from the previous pagination request. </param>
        /// <param name="limit"> Number of fine-tuning jobs to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Result<ListPaginatedFineTuningJobsResponse> GetPaginatedFineTuningJobs(string after = null, long? limit = null, CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetPaginatedFineTuningJobs(after, limit, context);
            return Result.FromValue(ListPaginatedFineTuningJobsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPaginatedFineTuningJobsAsync(string,long?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="after"> Identifier for the last job from the previous pagination request. </param>
        /// <param name="limit"> Number of fine-tuning jobs to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetPaginatedFineTuningJobsAsync(string after, long? limit, RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetPaginatedFineTuningJobs");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetPaginatedFineTuningJobsRequest(after, limit, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPaginatedFineTuningJobs(string,long?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="after"> Identifier for the last job from the previous pagination request. </param>
        /// <param name="limit"> Number of fine-tuning jobs to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetPaginatedFineTuningJobs(string after, long? limit, RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetPaginatedFineTuningJobs");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetPaginatedFineTuningJobsRequest(after, limit, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get info about a fine-tuning job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// </summary>
        /// <param name="fineTuningJobId"> The String to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<FineTuningJob>> RetrieveFineTuningJobAsync(string fineTuningJobId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await RetrieveFineTuningJobAsync(fineTuningJobId, context).ConfigureAwait(false);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Get info about a fine-tuning job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// </summary>
        /// <param name="fineTuningJobId"> The String to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<FineTuningJob> RetrieveFineTuningJob(string fineTuningJobId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = RetrieveFineTuningJob(fineTuningJobId, context);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Get info about a fine-tuning job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFineTuningJobAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> RetrieveFineTuningJobAsync(string fineTuningJobId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFineTuningJobRequest(fineTuningJobId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get info about a fine-tuning job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFineTuningJob(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result RetrieveFineTuningJob(string fineTuningJobId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFineTuningJobRequest(fineTuningJobId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get status updates for a fine-tuning job. </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to get events for. </param>
        /// <param name="after"> Identifier for the last event from the previous pagination request. </param>
        /// <param name="limit"> Number of events to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<ListFineTuningJobEventsResponse>> GetFineTuningEventsAsync(string fineTuningJobId, string after = null, int? limit = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetFineTuningEventsAsync(fineTuningJobId, after, limit, context).ConfigureAwait(false);
            return Result.FromValue(ListFineTuningJobEventsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Get status updates for a fine-tuning job. </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to get events for. </param>
        /// <param name="after"> Identifier for the last event from the previous pagination request. </param>
        /// <param name="limit"> Number of events to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<ListFineTuningJobEventsResponse> GetFineTuningEvents(string fineTuningJobId, string after = null, int? limit = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetFineTuningEvents(fineTuningJobId, after, limit, context);
            return Result.FromValue(ListFineTuningJobEventsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Get status updates for a fine-tuning job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTuningEventsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to get events for. </param>
        /// <param name="after"> Identifier for the last event from the previous pagination request. </param>
        /// <param name="limit"> Number of events to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetFineTuningEventsAsync(string fineTuningJobId, string after, int? limit, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTuningEvents");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTuningEventsRequest(fineTuningJobId, after, limit, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get status updates for a fine-tuning job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTuningEvents(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to get events for. </param>
        /// <param name="after"> Identifier for the last event from the previous pagination request. </param>
        /// <param name="limit"> Number of events to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetFineTuningEvents(string fineTuningJobId, string after, int? limit, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTuningEvents");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTuningEventsRequest(fineTuningJobId, after, limit, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Immediately cancel a fine-tune job. </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<FineTuningJob>> CancelFineTuningJobAsync(string fineTuningJobId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await CancelFineTuningJobAsync(fineTuningJobId, context).ConfigureAwait(false);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Immediately cancel a fine-tune job. </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<FineTuningJob> CancelFineTuningJob(string fineTuningJobId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = CancelFineTuningJob(fineTuningJobId, context);
            return Result.FromValue(FineTuningJob.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Immediately cancel a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelFineTuningJobAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CancelFineTuningJobAsync(string fineTuningJobId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CancelFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelFineTuningJobRequest(fineTuningJobId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Immediately cancel a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelFineTuningJob(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuningJobId"> The ID of the fine-tuning job to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuningJobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuningJobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CancelFineTuningJob(string fineTuningJobId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuningJobId, nameof(fineTuningJobId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CancelFineTuningJob");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelFineTuningJobRequest(fineTuningJobId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <param name="createCompletionRequest"> The CreateCompletionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createCompletionRequest"/> is null. </exception>
        public virtual async Task<Result<CreateCompletionResponse>> CreateCompletionAsync(CreateCompletionRequest createCompletionRequest, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(createCompletionRequest, nameof(createCompletionRequest));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = createCompletionRequest.ToRequestBody();
            Result result = await CreateCompletionAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateCompletionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <param name="createCompletionRequest"> The CreateCompletionRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createCompletionRequest"/> is null. </exception>
        public virtual Result<CreateCompletionResponse> CreateCompletion(CreateCompletionRequest createCompletionRequest, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(createCompletionRequest, nameof(createCompletionRequest));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = createCompletionRequest.ToRequestBody();
            Result result = CreateCompletion(content, context);
            return Result.FromValue(CreateCompletionResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCompletionAsync(CreateCompletionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateCompletionAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateCompletion");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateCompletionRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCompletion(CreateCompletionRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateCompletion(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateCompletion");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateCompletionRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <param name="edit"> The CreateEditRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="edit"/> is null. </exception>
        [Obsolete("deprecated")]
        public virtual async Task<Result<CreateEditResponse>> CreateEditAsync(CreateEditRequest edit, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(edit, nameof(edit));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = edit.ToRequestBody();
            Result result = await CreateEditAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateEditResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <param name="edit"> The CreateEditRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="edit"/> is null. </exception>
        [Obsolete("deprecated")]
        public virtual Result<CreateEditResponse> CreateEdit(CreateEditRequest edit, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(edit, nameof(edit));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = edit.ToRequestBody();
            Result result = CreateEdit(content, context);
            return Result.FromValue(CreateEditResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateEditAsync(CreateEditRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> CreateEditAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateEdit");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateEditRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateEdit(CreateEditRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result CreateEdit(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateEdit");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateEditRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates an embedding vector representing the input text. </summary>
        /// <param name="embedding"> The CreateEmbeddingRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="embedding"/> is null. </exception>
        public virtual async Task<Result<CreateEmbeddingResponse>> CreateEmbeddingAsync(CreateEmbeddingRequest embedding, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(embedding, nameof(embedding));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = embedding.ToRequestBody();
            Result result = await CreateEmbeddingAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(CreateEmbeddingResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates an embedding vector representing the input text. </summary>
        /// <param name="embedding"> The CreateEmbeddingRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="embedding"/> is null. </exception>
        public virtual Result<CreateEmbeddingResponse> CreateEmbedding(CreateEmbeddingRequest embedding, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(embedding, nameof(embedding));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = embedding.ToRequestBody();
            Result result = CreateEmbedding(content, context);
            return Result.FromValue(CreateEmbeddingResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates an embedding vector representing the input text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateEmbeddingAsync(CreateEmbeddingRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateEmbeddingAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateEmbedding");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateEmbeddingRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates an embedding vector representing the input text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateEmbedding(CreateEmbeddingRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateEmbedding(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateEmbedding");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateEmbeddingRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of files that belong to the user's organization. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Result<ListFilesResponse>> GetFilesAsync(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetFilesAsync(context).ConfigureAwait(false);
            return Result.FromValue(ListFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of files that belong to the user's organization. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Result<ListFilesResponse> GetFiles(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetFiles(context);
            return Result.FromValue(ListFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of files that belong to the user's organization.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFilesAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetFilesAsync(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFiles");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFilesRequest(context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of files that belong to the user's organization.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFiles(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetFiles(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFiles");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFilesRequest(context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of files that belong to the user's organization. </summary>
        /// <param name="file"> The CreateFileRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="file"/> is null. </exception>
        public virtual async Task<Result<OpenAIFile>> CreateFileAsync(CreateFileRequest file, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(file, nameof(file));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = file.ToRequestBody();
            Result result = await CreateFileAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(OpenAIFile.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of files that belong to the user's organization. </summary>
        /// <param name="file"> The CreateFileRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="file"/> is null. </exception>
        public virtual Result<OpenAIFile> CreateFile(CreateFileRequest file, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(file, nameof(file));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = file.ToRequestBody();
            Result result = CreateFile(content, context);
            return Result.FromValue(OpenAIFile.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of files that belong to the user's organization.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFileAsync(CreateFileRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateFileAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFileRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of files that belong to the user's organization.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFile(CreateFileRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateFile(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFileRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns information about a specific file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<OpenAIFile>> RetrieveFileAsync(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await RetrieveFileAsync(fileId, context).ConfigureAwait(false);
            return Result.FromValue(OpenAIFile.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns information about a specific file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<OpenAIFile> RetrieveFile(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = RetrieveFile(fileId, context);
            return Result.FromValue(OpenAIFile.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns information about a specific file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFileAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> RetrieveFileAsync(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFileRequest(fileId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns information about a specific file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFile(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result RetrieveFile(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFileRequest(fileId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<DeleteFileResponse>> DeleteFileAsync(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await DeleteFileAsync(fileId, context).ConfigureAwait(false);
            return Result.FromValue(DeleteFileResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Delete a file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<DeleteFileResponse> DeleteFile(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = DeleteFile(fileId, context);
            return Result.FromValue(DeleteFileResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Delete a file
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFileAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> DeleteFileAsync(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.DeleteFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDeleteFileRequest(fileId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a file
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFile(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result DeleteFile(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.DeleteFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDeleteFileRequest(fileId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the contents of the specified file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<string>> DownloadFileAsync(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await DownloadFileAsync(fileId, context).ConfigureAwait(false);
            return Result.FromValue(result.GetRawResponse().Content.ToObjectFromJson<string>(), result.GetRawResponse());
        }

        /// <summary> Returns the contents of the specified file. </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<string> DownloadFile(string fileId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = DownloadFile(fileId, context);
            return Result.FromValue(result.GetRawResponse().Content.ToObjectFromJson<string>(), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns the contents of the specified file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DownloadFileAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> DownloadFileAsync(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.DownloadFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDownloadFileRequest(fileId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns the contents of the specified file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DownloadFile(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fileId"> The ID of the file to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result DownloadFile(string fileId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.DownloadFile");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDownloadFileRequest(fileId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// </summary>
        /// <param name="fineTune"> The CreateFineTuneRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTune"/> is null. </exception>
        [Obsolete("deprecated")]
        public virtual async Task<Result<FineTune>> CreateFineTuneAsync(CreateFineTuneRequest fineTune, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(fineTune, nameof(fineTune));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = fineTune.ToRequestBody();
            Result result = await CreateFineTuneAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// </summary>
        /// <param name="fineTune"> The CreateFineTuneRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTune"/> is null. </exception>
        [Obsolete("deprecated")]
        public virtual Result<FineTune> CreateFineTune(CreateFineTuneRequest fineTune, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(fineTune, nameof(fineTune));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = fineTune.ToRequestBody();
            Result result = CreateFineTune(content, context);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFineTuneAsync(CreateFineTuneRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> CreateFineTuneAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFineTuneRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a job that fine-tunes a specified model from a given dataset.
        ///
        /// Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFineTune(CreateFineTuneRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result CreateFineTune(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateFineTuneRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List your organization's fine-tuning jobs. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        [Obsolete("deprecated")]
        public virtual async Task<Result<ListFineTunesResponse>> GetFineTunesAsync(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetFineTunesAsync(context).ConfigureAwait(false);
            return Result.FromValue(ListFineTunesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> List your organization's fine-tuning jobs. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        [Obsolete("deprecated")]
        public virtual Result<ListFineTunesResponse> GetFineTunes(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetFineTunes(context);
            return Result.FromValue(ListFineTunesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] List your organization's fine-tuning jobs
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTunesAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> GetFineTunesAsync(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTunes");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTunesRequest(context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List your organization's fine-tuning jobs
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTunes(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result GetFineTunes(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTunes");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTunesRequest(context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets info about the fine-tune job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual async Task<Result<FineTune>> RetrieveFineTuneAsync(string fineTuneId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await RetrieveFineTuneAsync(fineTuneId, context).ConfigureAwait(false);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Gets info about the fine-tune job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual Result<FineTune> RetrieveFineTune(string fineTuneId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = RetrieveFineTune(fineTuneId, context);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Gets info about the fine-tune job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFineTuneAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> RetrieveFineTuneAsync(string fineTuneId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFineTuneRequest(fineTuneId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets info about the fine-tune job.
        ///
        /// [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveFineTune(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result RetrieveFineTune(string fineTuneId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.RetrieveFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveFineTuneRequest(fineTuneId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get fine-grained status updates for a fine-tune job. </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to get events for. </param>
        /// <param name="stream">
        /// Whether to stream events for the fine-tune job. If set to true, events will be sent as
        /// data-only
        /// [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
        /// as they become available. The stream will terminate with a `data: [DONE]` message when the
        /// job is finished (succeeded, cancelled, or failed).
        ///
        /// If set to false, only events generated so far will be returned.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual async Task<Result<ListFineTuneEventsResponse>> GetFineTuneEventsAsync(string fineTuneId, bool? stream = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetFineTuneEventsAsync(fineTuneId, stream, context).ConfigureAwait(false);
            return Result.FromValue(ListFineTuneEventsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Get fine-grained status updates for a fine-tune job. </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to get events for. </param>
        /// <param name="stream">
        /// Whether to stream events for the fine-tune job. If set to true, events will be sent as
        /// data-only
        /// [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
        /// as they become available. The stream will terminate with a `data: [DONE]` message when the
        /// job is finished (succeeded, cancelled, or failed).
        ///
        /// If set to false, only events generated so far will be returned.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual Result<ListFineTuneEventsResponse> GetFineTuneEvents(string fineTuneId, bool? stream = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetFineTuneEvents(fineTuneId, stream, context);
            return Result.FromValue(ListFineTuneEventsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Get fine-grained status updates for a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTuneEventsAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to get events for. </param>
        /// <param name="stream">
        /// Whether to stream events for the fine-tune job. If set to true, events will be sent as
        /// data-only
        /// [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
        /// as they become available. The stream will terminate with a `data: [DONE]` message when the
        /// job is finished (succeeded, cancelled, or failed).
        ///
        /// If set to false, only events generated so far will be returned.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> GetFineTuneEventsAsync(string fineTuneId, bool? stream, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTuneEvents");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTuneEventsRequest(fineTuneId, stream, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get fine-grained status updates for a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFineTuneEvents(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to get events for. </param>
        /// <param name="stream">
        /// Whether to stream events for the fine-tune job. If set to true, events will be sent as
        /// data-only
        /// [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
        /// as they become available. The stream will terminate with a `data: [DONE]` message when the
        /// job is finished (succeeded, cancelled, or failed).
        ///
        /// If set to false, only events generated so far will be returned.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result GetFineTuneEvents(string fineTuneId, bool? stream, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetFineTuneEvents");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetFineTuneEventsRequest(fineTuneId, stream, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Immediately cancel a fine-tune job. </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual async Task<Result<FineTune>> CancelFineTuneAsync(string fineTuneId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await CancelFineTuneAsync(fineTuneId, context).ConfigureAwait(false);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Immediately cancel a fine-tune job. </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("deprecated")]
        public virtual Result<FineTune> CancelFineTune(string fineTuneId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = CancelFineTune(fineTuneId, context);
            return Result.FromValue(FineTune.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Immediately cancel a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelFineTuneAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual async Task<Result> CancelFineTuneAsync(string fineTuneId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CancelFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelFineTuneRequest(fineTuneId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Immediately cancel a fine-tune job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelFineTune(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="fineTuneId"> The ID of the fine-tune job to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fineTuneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="fineTuneId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("deprecated")]
        public virtual Result CancelFineTune(string fineTuneId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(fineTuneId, nameof(fineTuneId));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CancelFineTune");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelFineTuneRequest(fineTuneId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Lists the currently available models, and provides basic information about each one such as the
        /// owner and availability.
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Result<ListModelsResponse>> GetModelsAsync(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetModelsAsync(context).ConfigureAwait(false);
            return Result.FromValue(ListModelsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Lists the currently available models, and provides basic information about each one such as the
        /// owner and availability.
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Result<ListModelsResponse> GetModels(CancellationToken cancellationToken = default)
        {
            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetModels(context);
            return Result.FromValue(ListModelsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Lists the currently available models, and provides basic information about each one such as the
        /// owner and availability.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetModelsAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetModelsAsync(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetModels");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetModelsRequest(context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the currently available models, and provides basic information about each one such as the
        /// owner and availability.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetModels(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetModels(RequestOptions context)
        {
            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.GetModels");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetModelsRequest(context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves a model instance, providing basic information about the model such as the owner and
        /// permissioning.
        /// </summary>
        /// <param name="model"> The ID of the model to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<Model>> RetrieveAsync(string model, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await RetrieveAsync(model, context).ConfigureAwait(false);
            return Result.FromValue(Model.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// Retrieves a model instance, providing basic information about the model such as the owner and
        /// permissioning.
        /// </summary>
        /// <param name="model"> The ID of the model to use for this request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<Model> Retrieve(string model, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = Retrieve(model, context);
            return Result.FromValue(Model.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a model instance, providing basic information about the model such as the owner and
        /// permissioning.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RetrieveAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="model"> The ID of the model to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> RetrieveAsync(string model, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.Retrieve");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveRequest(model, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a model instance, providing basic information about the model such as the owner and
        /// permissioning.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Retrieve(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="model"> The ID of the model to use for this request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result Retrieve(string model, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.Retrieve");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateRetrieveRequest(model, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a fine-tuned model. You must have the Owner role in your organization to delete a model. </summary>
        /// <param name="model"> The model to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<DeleteModelResponse>> DeleteAsync(string model, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await DeleteAsync(model, context).ConfigureAwait(false);
            return Result.FromValue(DeleteModelResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Delete a fine-tuned model. You must have the Owner role in your organization to delete a model. </summary>
        /// <param name="model"> The model to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<DeleteModelResponse> Delete(string model, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = Delete(model, context);
            return Result.FromValue(DeleteModelResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="model"> The model to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> DeleteAsync(string model, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.Delete");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDeleteRequest(model, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Delete(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="model"> The model to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="model"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="model"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result Delete(string model, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(model, nameof(model));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.Delete");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateDeleteRequest(model, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates an image given a prompt. </summary>
        /// <param name="image"> The CreateImageRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual async Task<Result<ImagesResponse>> CreateImageAsync(CreateImageRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = await CreateImageAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates an image given a prompt. </summary>
        /// <param name="image"> The CreateImageRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual Result<ImagesResponse> CreateImage(CreateImageRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = CreateImage(content, context);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates an image given a prompt
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImageAsync(CreateImageRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateImageAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImage");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates an image given a prompt
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImage(CreateImageRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateImage(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImage");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates an edited or extended image given an original image and a prompt. </summary>
        /// <param name="image"> The CreateImageEditRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual async Task<Result<ImagesResponse>> CreateImageEditAsync(CreateImageEditRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = await CreateImageEditAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates an edited or extended image given an original image and a prompt. </summary>
        /// <param name="image"> The CreateImageEditRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual Result<ImagesResponse> CreateImageEdit(CreateImageEditRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = CreateImageEdit(content, context);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates an edited or extended image given an original image and a prompt.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImageEditAsync(CreateImageEditRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateImageEditAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImageEdit");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageEditRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates an edited or extended image given an original image and a prompt.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImageEdit(CreateImageEditRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateImageEdit(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImageEdit");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageEditRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates an edited or extended image given an original image and a prompt. </summary>
        /// <param name="image"> The CreateImageVariationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual async Task<Result<ImagesResponse>> CreateImageVariationAsync(CreateImageVariationRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = await CreateImageVariationAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates an edited or extended image given an original image and a prompt. </summary>
        /// <param name="image"> The CreateImageVariationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="image"/> is null. </exception>
        public virtual Result<ImagesResponse> CreateImageVariation(CreateImageVariationRequest image, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(image, nameof(image));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = image.ToRequestBody();
            Result result = CreateImageVariation(content, context);
            return Result.FromValue(ImagesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates an edited or extended image given an original image and a prompt.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImageVariationAsync(CreateImageVariationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateImageVariationAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImageVariation");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageVariationRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates an edited or extended image given an original image and a prompt.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateImageVariation(CreateImageVariationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateImageVariation(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateImageVariation");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateImageVariationRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Classifies if text violates OpenAI's Content Policy. </summary>
        /// <param name="content"> The CreateModerationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<Result<CreateModerationResponse>> CreateModerationAsync(CreateModerationRequest content, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content0 = content.ToRequestBody();
            Result result = await CreateModerationAsync(content0, context).ConfigureAwait(false);
            return Result.FromValue(CreateModerationResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Classifies if text violates OpenAI's Content Policy. </summary>
        /// <param name="content"> The CreateModerationRequest to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual Result<CreateModerationResponse> CreateModeration(CreateModerationRequest content, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content0 = content.ToRequestBody();
            Result result = CreateModeration(content0, context);
            return Result.FromValue(CreateModerationResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Classifies if text violates OpenAI's Content Policy
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateModerationAsync(CreateModerationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateModerationAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateModeration");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateModerationRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Classifies if text violates OpenAI's Content Policy
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateModeration(CreateModerationRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestErrorException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateModeration(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("OpenAIClient.CreateModeration");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateModerationRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal PipelineMessage CreateCreateTranscriptionRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/audio/transcriptions", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateTranslationRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/audio/translations", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateChatCompletionRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/chat/completions", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateFineTuningJobRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine_tuning/jobs", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateGetPaginatedFineTuningJobsRequest(string after, long? limit, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine_tuning/jobs", false);
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateRetrieveFineTuningJobRequest(string fineTuningJobId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine_tuning/jobs/", false);
            uri.AppendPath(fineTuningJobId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetFineTuningEventsRequest(string fineTuningJobId, string after, int? limit, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine_tuning/jobs/", false);
            uri.AppendPath(fineTuningJobId, true);
            uri.AppendPath("/events", false);
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCancelFineTuningJobRequest(string fineTuningJobId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine_tuning/jobs/", false);
            uri.AppendPath(fineTuningJobId, true);
            uri.AppendPath("/cancel", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCreateCompletionRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/completions", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateEditRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/edits", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateEmbeddingRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/embeddings", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateGetFilesRequest(RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/files", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCreateFileRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/files", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateRetrieveFileRequest(string fileId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/files/files/", false);
            uri.AppendPath(fileId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateDeleteFileRequest(string fileId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("DELETE");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/files/files/", false);
            uri.AppendPath(fileId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateDownloadFileRequest(string fileId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/files/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendPath("/content", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCreateFineTuneRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine-tunes", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateGetFineTunesRequest(RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine-tunes", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateRetrieveFineTuneRequest(string fineTuneId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine-tunes/", false);
            uri.AppendPath(fineTuneId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetFineTuneEventsRequest(string fineTuneId, bool? stream, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine-tunes/", false);
            uri.AppendPath(fineTuneId, true);
            uri.AppendPath("/events", false);
            if (stream != null)
            {
                uri.AppendQuery("stream", stream.Value, true);
            }
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCancelFineTuneRequest(string fineTuneId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/fine-tunes/", false);
            uri.AppendPath(fineTuneId, true);
            uri.AppendPath("/cancel", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetModelsRequest(RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/models", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateRetrieveRequest(string model, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/models/", false);
            uri.AppendPath(model, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateDeleteRequest(string model, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("DELETE");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/models/", false);
            uri.AppendPath(model, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateCreateImageRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/images/generations", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateImageEditRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/images/edits", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateImageVariationRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/images/variations", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateModerationRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/moderations", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestOptions DefaultRequestContext = new RequestOptions();
        internal static RequestOptions FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestOptions() { CancellationToken = cancellationToken };
        }

        private static ResponseErrorClassifier _responseErrorClassifier200;
        private static ResponseErrorClassifier ResponseErrorClassifier200 => _responseErrorClassifier200 ??= new StatusResponseClassifier(stackalloc ushort[] { 200 });
    }
}
