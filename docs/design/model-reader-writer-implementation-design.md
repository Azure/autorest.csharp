# Azure SDK Design Spec for implementation of `ModelReaderWriter`

- [Summary](#summary)
- [Problem Statement or Scenario Description](#problem-statement-or-scenario-description)
- [Scope: Goals and Non-Goals](#scope-goals-and-non-goals)
- [Feature Design](#feature-design)
- [Detailed Implementation](#detailed-implementation)

## Summary

This design specification is for the implementation of `ModelReaderWriter` related interfaces on the generated libraries, not the design specification of `ModelReaderWriter` itself.

The implementation of `ModelReaderWriter` might change in the future when we have further consolidations of existing interfaces.

For details of `ModelReaderWriter`, please refer to [ModelReaderWriter](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/System.ClientModel/README.md).

## Problem Statement or Scenario Description

Our SDK libraries ship with a set of generated models which are used to represent the data structures of the service. These models are shipped with a set of serialization and deserialization but those are only designed for us to use internally by our generated operation to build the payload or parse the response back to the models.

In this design, our customers will not be able to serialize or deserialize the models in the same way as we do. They could only serialize the model using the default way which is not usually correct. An intuitive example of this is when there is an "extensible enum" type in the model:
```csharp
public partial class Foo
{
    public ExtensibleEnumType? Bar { get; set; }
}

public partial struct ExtensibleEnumType : IEquatable<ExtensibleEnumType>
{
    private readonly string _value;

    public ExtensibleEnumType(string value)
    {
        _value = value ?? throw new ArgumentNullException(nameof(value));
    }
}
```

The default behavior of the most widely used JSON serializer and deserializer is usually: they serialize classes and structs in the same way, assuming that they are models containing properties. This is true for our classes, but for structs, it is not always true. The extensible enums are modeled as structs, but they are actually serialized to a string value in our internal implementation when building the payload or parsing the response. For example, the `Foo` model above are expected to be serialized to the following JSON:
```json
{
    "bar": "value"
}
```
but in the default behavior of `System.Text.JsonSerializer`, it will be serialized to:
```json
{
    "bar": {}
}
```
which is completely incorrect.

Therefore we need a way to let our customer could publicly access to our internal implementation of the serialization and deserialization because they could be properly generated by the generator.

`System.ClientModel.Primitives.ModelReaderWriter` is designed to solve this problem. It provides utility methods to serialize and deserialize models. In the meantime, to use its functionality, our models need to implement the interfaces defined in namespace `System.ClientModel.Primitives`: `IPersistableModel<T>` and `IJsonModel<T>`.

## Scope: Goals and Non-Goals

## Feature Design

[Describe what the solution is, including the naming and scope,  what options are considered and why the proposed options is chosen] 

<Your content here> 

## Detailed Implementation

<Your content here> 
