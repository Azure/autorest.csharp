# Azure SDK Design Spec for implementation of `ModelReaderWriter`

- [Summary](#summary)
- [Problem Statement or Scenario Description](#problem-statement-or-scenario-description)
- [Scope: Goals and Non-Goals](#scope-goals-and-non-goals)
- [Feature Design](#feature-design)
- [Detailed Implementation](#detailed-implementation)

## Summary

This design specification is for the implementation of `ModelReaderWriter` related interfaces on the generated libraries, not the design specification of `ModelReaderWriter` itself.

The implementation of `ModelReaderWriter` might change in the future when we have further consolidations of existing interfaces.

For details of `ModelReaderWriter`, please refer to [ModelReaderWriter](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/System.ClientModel/README.md).

## Problem Statement or Scenario Description

Our SDK libraries ship with a set of generated models which are used to represent the data structures of the service. These models are shipped with a set of serialization and deserialization but those are only designed for us to use internally by our generated operation to build the payload or parse the response back to the models.

In this design, our customers will not be able to serialize or deserialize the models in the same way as we do. They could only serialize the model using the default way which is not usually correct. An intuitive example of this is when there is an "extensible enum" type in the model:
```csharp
public partial class Foo
{
    public ExtensibleEnumType? Bar { get; set; }
}

public partial struct ExtensibleEnumType : IEquatable<ExtensibleEnumType>
{
    private readonly string _value;

    public ExtensibleEnumType(string value)
    {
        _value = value ?? throw new ArgumentNullException(nameof(value));
    }
}
```

The default behavior of the most widely used JSON serializer and deserializer is usually: they serialize classes and structs in the same way, assuming that they are models containing properties. This is true for our classes, but for structs, it is not always true. The extensible enums are modeled as structs, but they are actually serialized to a string value in our internal implementation when building the payload or parsing the response. For example, the `Foo` model above are expected to be serialized to the following JSON:
```json
{
    "bar": "value"
}
```
but in the default behavior of `System.Text.JsonSerializer`, it will be serialized to:
```json
{
    "bar": {}
}
```
which is completely incorrect.

Therefore we need a way to let our customer could publicly access to our internal implementation of the serialization and deserialization because they could be properly generated by the generator.

`System.ClientModel.Primitives.ModelReaderWriter` is designed to solve this problem. It provides utility methods to serialize and deserialize models. In the meantime, to use its functionality, our models need to implement the interfaces defined in namespace `System.ClientModel.Primitives`: `IPersistableModel<T>` and `IJsonModel<T>`.

## Scope: Goals and Non-Goals

### Goals

Design a proper implementation for the model reader writer to consume, which should keep our current wire behavior unchanged, and meet the requirement for our customers to persistantly store their data from the models.

### Non-Goals

This is not a design for the APIs in model reader writer.

## Feature Design

### Introduction of the methods in the interfaces

The definitions of the interfaces we would like to implement are:
```csharp
namespace System.ClientModel.Primitives
{
    public partial interface IJsonModel<out T> : System.ClientModel.Primitives.IPersistableModel<T>
    {
        T Create(ref System.Text.Json.Utf8JsonReader reader, System.ClientModel.Primitives.ModelReaderWriterOptions options);
        void Write(System.Text.Json.Utf8JsonWriter writer, System.ClientModel.Primitives.ModelReaderWriterOptions options);
    }
    public partial interface IPersistableModel<out T>
    {
        T Create(System.BinaryData data, System.ClientModel.Primitives.ModelReaderWriterOptions options);
        string GetFormatFromOptions(System.ClientModel.Primitives.ModelReaderWriterOptions options);
        System.BinaryData Write(System.ClientModel.Primitives.ModelReaderWriterOptions options);
    }
    public partial class ModelReaderWriterOptions
    {
        public ModelReaderWriterOptions(string format) { }
        public string Format { get { throw null; } }
        public static System.ClientModel.Primitives.ModelReaderWriterOptions Json { get { throw null; } }
        public static System.ClientModel.Primitives.ModelReaderWriterOptions Xml { get { throw null; } }
    }
}
```

The methods in `IJsonModel<T>` controls how the model writes into a JSON or reads from JSON via `Utf8JsonWriter` or `Utf8JsonReader`. The methods in `IPersistableModel<T>` controls how the model writes into a BinaryData or reads from a BinaryData which serves a general purpose of serialization and deserialization including JSON case.

### Implementation design

Our general principals are:
1. The behavior should keep unchanged when the library calls it on wire.
2. When the customer calls the `ModelReaderWriter.Read` API, it should properly deserialize all the content in the input into the model (including the properties that this model does not currently support).
3. When the customer calls the `ModelReaderWriter.Write` API, it should properly serialize all the properties into the result (including the properties that this model does not currently support).

We should have the following methods in a model:

1. `IUtf8JsonSerializable.Write(Utf8JsonWriter writer)` method.
2. `IJsonModel<T>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)` method.
3. `IJsonModel<T>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)` method.
4. `IPersistableModel<T>.Write(ModelReaderWriterOptions options)` method.
5. `IPersistableModel<T>.Create(BinaryData data, ModelReaderWriterOptions options)` method.
6. the static `Deserialize{ModelName}(JsonElement element, ModelReaderWriterOptions options = null)` method.

If the model supports `xml` format, it will contain the following methods:
1. `IXmlSerializable.Write(XmlWriter writer, string nameHint)` method.
2. `WriteInternal(XmlWriter writer, string nameHint, ModelReaderWriterOptions options)` method.
3. the static `Deserialize{ModelName}(XElement element, ModelReaderWriterOptions options = null)` method.

#### The changes on models

All models will now have a field `private IDictionary<string, BinaryData> _serializedAdditionalRawData`, if the model has a base type, the field should change to `private protected IDictionary<string, BinaryData> _serializedAdditionalRawData`.

This private field works exactly the same as additional properties property, it should vanish when the model or any of its base type has an additional properties property defined.

All models will always have an internal constructor that takes all properties as parameters and the `serializedAdditionalRawData` if itself or any of its direct or indirect base type has `serializedAdditionalRawData` field.

All models will always have an internal constructor with no parameter if it does not have one for deserialization.

#### The `IUtf8JsonSerializable.Write(Utf8JsonWriter writer)` method

Our operations will call this method to serialize the model into payload, to keep the behavior unchanged for wire cases, we should now implement the internal interface method `IUtf8JsonSerializable.Write(Utf8JsonWriter)` in this way:
```csharp
public partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>
{
    void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<Foo>)this).Write(writer, new ModelReaderWriterOptions("W"));
}
```

The cast `(IJsonModel<Foo>)this` is required because the method implementation of all interfaces will be explicitly implemented. And here we use `W` as the format for wire serialization and deserialization.

#### The `IJsonModel<T>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)` method

This method should iterate all the properties on this model, and write it into the `Utf8JsonWriter`.

For readonly properties, we should not write it on wire because we previously did not write it, we should check the value of `Format` in the `options`. For example we have a model `Foo` with two properties `A` and `B`:
```csharp
public partial class Foo
{
    public string A { get; set; } // this property is not readonly

    public string B { get; } // this property is readonly
}
```

The implementation of `IJsonModel<T>.Write` should also validate the format because the methods on this interface could only support Json:
```csharp
var format = options.Format == "W" ? ((IPersistableModel<T>)this).GetFormatFromOptions(options) : options.Format;
if (format != "J")
{
    throw new InvalidOperationException($"The model {nameof(T)} does not support '{format}' format.");
}
```
In this implementation, the method `IPersistableModel<T>.GetFormatFromOptions` is called to get the real format when we get the format of `W` which represents "wire", and then throw exception if the actual format is not `J` which represents "json".

In the wire serialization, we will only write property `A`, and in a Json serialization (invoked by our customer via `ModelReaderWriter`), we will write both properties `A` and `B` as well as everything in the `_serializedAdditionalRawData`, therefore the implementation should be:
```csharp
public partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>
{
    void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<Foo>)this).Write(writer, new ModelReaderWriterOptions("W"));

    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
    {
        var format = options.Format == "W" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;
        if (format != "J")
        {
            throw new InvalidOperationException($"The model {nameof(Foo)} does not support '{format}' format.");
        }

        writer.WriteStartObject();
        if (Optional.IsDefined(A))
        {
            writer.WritePropertyName("a"u8);
            writer.WriteStringValue(A);
        }
        if (options.Format != "W" && Optional.IsDefined(B))
        {
            writer.WritePropertyName("b"u8);
            writer.WriteStringValue(B);
        }
        if (options.Format != "W" && _serializedAdditionalRawData != null)
        {
            foreach (var item in _serializedAdditionalRawData)
            {
                writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                writer.WriteRawValue(item.Value);
#else
                using (JsonDocument document = JsonDocument.Parse(item.Value))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
        }
        writer.WriteEndObject();
    }
}
```

#### The `IPersistableModel<T>.Write(ModelReaderWriterOptions options)` method

This method should switch all possible formats this model supports, and calls their respective implementations, such as:

```csharp
public partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>, IXmlSerializable, IPersistableModel<Foo>
{
    BinaryData IPersistableModel<Foo>.Write(ModelReaderWriterOptions options)
    {
        var format = options.Format == "W" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;

        switch (format)
        {
            case "J":
                return ModelReaderWriter.Write(this, options);
            case "X":
                {
                    using MemoryStream stream = new MemoryStream();
                    using XmlWriter writer = XmlWriter.Create(stream);
                    WriteInternal(writer, null, options);
                    writer.Flush();
                    return new BinaryData(stream.GetBuffer().AsMemory(0, (int)stream.Position));
                }
            default:
                throw new InvalidOperationException($"The model {nameof(Foo)} does not support '{options.Format}' format.");
        }
    }
}
```

The `J` case we just call `ModelReaderWriter.Write`, and this will not raise an infinite call issue because the implementation of `ModelReaderWriter.Write` will end up in the method `IJsonModel<T>.Write` and will not circle back to this method.

#### The `Create` methods

These `Create` methods will just call the corresponding implementation of the static `Deserialize{ModelName}` method.
