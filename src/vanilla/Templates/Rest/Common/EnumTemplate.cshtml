@using System.Linq
@using AutoRest.Core.Model
@inherits AutoRest.Core.Template<AutoRest.CSharp.Model.EnumTypeCs>
@Header("// ")
@EmptyLine
namespace @(Settings.Namespace).@(Settings.ModelsName)
{
@EmptyLine
    /// <summary>
    @WrapComment("/// ", "Defines values for " + Model.Name + ".")
    /// </summary>
    @if(Settings.CustomSettings.ContainsKey("ExtensibleEnums") && (bool)Settings.CustomSettings["ExtensibleEnums"])
    {
    var underlyingType = (Model.UnderlyingType == null)? "string" : Model.UnderlyingType.ToString();
    var hasAllowedValues = Model.Values.Any(val=>val.AllowedValues!=null);
    
    @:[Newtonsoft.Json.JsonConverter(typeof(Microsoft.Rest.ClientRuntime.Serialization.ExtensibleEnumConverter<@Model.ClassName, @underlyingType>))]
    @:public sealed class @Model.ClassName : Microsoft.Rest.ExtensibleEnum<@Model.ClassName, @underlyingType>
    @:{
        @:private @(Model.ClassName+"("+underlyingType+" value):base(value)")
        @:{

        @:}

        @EmptyLine
        @foreach (var t in Model.Values)
        {
            if (t.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", t.Description)
        /// </summary>
        </text>
        }
        var initName = (underlyingType == "string" || (Model.UnderlyingType != null && Model.UnderlyingType.KnownPrimaryType == KnownPrimaryType.String)) ? "\""+t.SerializedName+"\"": t.SerializedName;
        @:public static readonly @Model.ClassName @t.MemberName = @(initName);
        @EmptyLine
    }

    if(hasAllowedValues)
    {
        @:///<summary>
        @WrapComment("/// ", "Static map to store allowed values for enums");
        @:///</summary>
        @EmptyLine
        @:AllowedValuesMap = new Dictionary<@underlyingType, @Model.ClassName>()
        @:{
            var initializers = Model.Values.SelectMany(enumVal=>enumVal.AllowedValues?.Select(allowedValue
                =>"{ "+((underlyingType=="string")?"\""+allowedValue+"\"": allowedValue.ToString())+", "+@enumVal.MemberName+"}"));
            @string.Join(", \n", initializers.ToArray());
        @:}
        
    }
        @EmptyLine
        <text>
        /// <summary>
        @WrapComment("/// ", "Defines ctor/explicit conversion from value type to "+Model.ClassName+".")
        /// </summary>
        /// <param name="value">string to convert.</param>
        /// <returns>The value as a @(Model.ClassName).</returns> </text>
        @:public static implicit operator @(Model.ClassName)(@underlyingType value) => Create(value);
        
        @EmptyLine
        <text>
        /// <summary>
        /// Create method used by deserializer to create instances of @Model.ClassName type
        /// </summary> 
        /// <returns>The value as a @(Model.ClassName).</returns> </text>
        @:public static @Model.ClassName Create(@underlyingType value)
        if(hasAllowedValues)
        {
        @:{ 
            @:if(AllowedValuesMap.ContainsKey(value))
            @:{
                @:return AllowedValuesMap[value];
            @:}
            @EmptyLine
            @:return _valueMap.GetOrAdd(value, (v) => new @(Model.ClassName)(v));
        @:}
        @EmptyLine
        }
        else
        {
            @:=> _valueMap.GetOrAdd(value, (v) => new @(Model.ClassName)(v));
        }
        
    @:}
    }
    else if (!Model.ModelAsString)
    {
    @:[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    @:public enum @Model.ClassName
    @:{
        var last = Model.Values.Last();
        foreach (var value in Model.Values)
        {
            if (value.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", value.Description)
        /// </summary>
</text>
        }
@:        [System.Runtime.Serialization.EnumMember(Value = "@value.SerializedName")]
          if (value == last)
          {
@:        @(value.MemberName)
          }
          else
          {
@:        @(value.MemberName),
          }
        }
    @:}
<text>
    internal static class @(Model.ClassName)EnumExtension
    {
        internal static string ToSerializedValue(this @(Model.ClassName)? value)
        {
            return value == null ? null : ((@(Model.ClassName))value).ToSerializedValue();
        }
@EmptyLine
        internal static string ToSerializedValue(this @(Model.ClassName) value)
        {
            switch( value )
            {
            @for (int i = 0; i < Model.Values.Count; i++)
            {<text>
                case @(Model.ClassName).@(Model.Values[i].MemberName):
                    return "@Model.Values[i].SerializedName";</text>
            }

            }
            return null;
        }
@EmptyLine
        internal static @(Model.ClassName)? Parse@(Model.ClassName)(this string value)
        {
            switch( value )
            {
            @for (int i = 0; i < Model.Values.Count; i++)
            {<text>
                case "@Model.Values[i].SerializedName":
                    return @(Model.ClassName).@(Model.Values[i].MemberName);</text>
            }

            }
            return null;
        }
    }
</text>
    }
    else
    {
    @:public static class @Model.ClassName
    @:{
        foreach (var t in Model.Values)
        {
            if (t.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", t.Description)
        /// </summary>
</text>
            }
@:        public const string @t.MemberName = "@t.SerializedName";
        }
    @:}
    }
}