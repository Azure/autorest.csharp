@using System.Linq
@using AutoRest.Core.Model
@inherits AutoRest.Core.Template<AutoRest.CSharp.Model.EnumTypeCs>
@Header("// ")
@EmptyLine
namespace @(Settings.Namespace).@(Settings.ModelsName)
{
@EmptyLine
    /// <summary>
    @WrapComment("/// ", "Defines values for " + Model.Name + ".")
    /// </summary>
    @if((bool)Settings.CustomSettings["ExtensibleEnums"])
    {
    @:[JsonConverter(typeof(ExtensibleEnumConverter<@Model.ClassName>))]
    @:public sealed class @Model.ClassName : ExtensibleEnum<@Model.ClassName>
    @:{
        @foreach (var t in Model.Values)
        {
            if (t.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", t.Description)
        /// </summary>
        </text>
        }
        string ctor = "new "+Model.ClassName+"(\""+t.Name+"\")";
        @:public static readonly @Model.ClassName @t.Name = new @(Model.ClassName)("@(t.Name)");
    }
    @EmptyLine
        @:private @(Model.ClassName)(string typeName) : base(typeName)
        @:{
            @:// Base class does all initialization.
        @:}
    @EmptyLine

        <text>
        /// <summary>
        /// Creates a new @(Model.ClassName) instance, or returns an existing instance if the given value matches that of a known @(Model.ClassName).
        /// </summary>
        /// <param name="value">Value of @(Model.ClassName).</param>
        /// <returns>@(Model.ClassName) instance with the given value.</returns> </text>
        @:public static @(Model.ClassName) Create(string value) => Lookup(value) ?? new @(Model.ClassName)(value);

        @EmptyLine
        <text>
        /// <summary>
        @WrapComment("/// ", "Creates a "+Model.ClassName+" for a collection of the given type.")
        /// </summary>
        /// <param name="elementType">The @(Model.ClassName) of the elements of the collection.</param>
        /// <returns>A new @(Model.ClassName) for a collection.</returns> </text>
        @:public static @(Model.ClassName) Collection(@Model.ClassName elementType)
        @:{
        @:    if(elementType == null)
        @:    {
        @:        throw new ArgumentNullException(elementType, nameof(elementType));
        @:    }
        @:    return new @(Model.ClassName)($"Collection({elementType})");
        @:}

        @EmptyLine
        <text>
        /// <summary>
        @WrapComment("/// ", "Defines implicit conversion from string to "+Model.ClassName+".")
        /// </summary>
        /// <param name="value">string to convert.</param>
        /// <returns>The string as a @(Model.ClassName).</returns> </text>
        @:public static implicit operator @(Model.ClassName)(string value) => Create(value);

        @EmptyLine        
    @:}
    }
    else if (!Model.ModelAsString)
    {
    @:[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    @:public enum @Model.ClassName
    @:{
        var last = Model.Values.Last();
        foreach (var value in Model.Values)
        {
            if (value.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", value.Description)
        /// </summary>
</text>
        }

@:        [System.Runtime.Serialization.EnumMember(Value = "@value.SerializedName")]
          if (value == last)
          {
@:        @(value.MemberName)
          }
          else
          {
@:        @(value.MemberName),
          }
        }
    @:}
<text>
    internal static class @(Model.ClassName)EnumExtension
    {
        internal static string ToSerializedValue(this @(Model.ClassName)? value)
        {
            return value == null ? null : ((@(Model.ClassName))value).ToSerializedValue();
        }
@EmptyLine
        internal static string ToSerializedValue(this @(Model.ClassName) value)
        {
            switch( value )
            {
            @for (int i = 0; i < Model.Values.Count; i++)
            {<text>
                case @(Model.ClassName).@(Model.Values[i].MemberName):
                    return "@Model.Values[i].SerializedName";</text>
            }

            }
            return null;
        }
@EmptyLine
        internal static @(Model.ClassName)? Parse@(Model.ClassName)(this string value)
        {
            switch( value )
            {
            @for (int i = 0; i < Model.Values.Count; i++)
            {<text>
                case "@Model.Values[i].SerializedName":
                    return @(Model.ClassName).@(Model.Values[i].MemberName);</text>
            }

            }
            return null;
        }
    }
</text>
    }
    else
    {
    @:public static class @Model.ClassName
    @:{
        foreach (var t in Model.Values)
        {
            if (t.Description != null)
            {<text>
        /// <summary>
        @WrapComment("/// ", t.Description)
        /// </summary>
</text>
            }
@:        public const string @t.MemberName = "@t.SerializedName";
        }
    @:}
    }
}